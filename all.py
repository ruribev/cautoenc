# -*- coding: utf-8 -*-
"""NNbasic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E3W-laLuFd2q1T2ym6JmWl-lSjxgdq_U
"""

from tensorflow.keras.models import load_model
from scipy.interpolate import interp1d
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import zipfile
import os

folder="./dataset_chunks"
os.makedirs(folder, exist_ok=True)
samples_per_file=10000
files=1

"""# Generate Dataset"""

def normalize_data(data):
    """ Normalizes data to have zero mean and unit variance. """
    mean = np.mean(data)
    std = np.std(data)
    return (data - mean) / std

def generate_variable_topographic_profile(num_points, range_parameter, sill):
    # Generate x values from 0 to 1000 evenly spaced
    x_values = np.linspace(0, 1000, num_points)

    # Base terrain using sine and cosine with random amplitudes and frequencies
    amplitude1 = np.random.uniform(10, 150)
    frequency1 = np.random.uniform(0.5, 3.0)
    amplitude2 = np.random.uniform(10, 150)
    frequency2 = np.random.uniform(0.5, 3.0)
    y_values = amplitude1 * np.sin(frequency1 * 2 * np.pi * x_values / 1000) + \
               amplitude2 * np.cos(frequency2 * 4 * np.pi * x_values / 1000)

    # Adding finer spatial variations
    fine_amplitude = np.random.uniform(1, 15)
    fine_frequency = np.random.uniform(1, 15)  # Higher frequency for finer details
    fine_variations = fine_amplitude * np.sin(fine_frequency * 2 * np.pi * x_values / 1000)

    # Spherical variogram for spatial correlation
    def spherical_variogram(h, range_a, sill):
        return np.where(h < range_a, sill * (1.5 * h / range_a - 0.5 * (h / range_a) ** 3), sill)

    distances = np.abs(x_values[:, None] - x_values[None, :])
    variogram_matrix = spherical_variogram(distances, range_parameter, sill)
    covariance_matrix = sill - variogram_matrix

    # Cholesky decomposition for spatially correlated noise
    try:
        cholesky_decomposition = np.linalg.cholesky(covariance_matrix)
    except np.linalg.LinAlgError:
        covariance_matrix = np.abs(covariance_matrix)
        cholesky_decomposition = np.linalg.cholesky(covariance_matrix)

    # Generate spatially correlated noise and add it to the fine variations
    random_noise = np.dot(cholesky_decomposition, np.random.normal(size=num_points))
    fine_variations += random_noise

    # Combine the base terrain and fine variations
    y_values += fine_variations

    # Stack x and y values into a 2D array
    data = np.column_stack(((x_values/250)-2, normalize_data(y_values)))
    return data

# Example usage with 1000 points

data = generate_variable_topographic_profile(300, 30, 50)
print(len(data))
plt.scatter(data[:,0], data[:,1], alpha=0.1)
start_end = [data[0, 1], data[-1, 1]]
plt.scatter([-2, 2], start_end, color='red', label='Conditions')

plt.show()

import uuid
import os

def create_dataset(files, samples_per_file, save_path):
    os.makedirs(save_path, exist_ok=True)  # Create the folder if it doesn't exist
    for _ in range(files):
        X, Y = [], []
        for _ in range(samples_per_file):
            data = generate_variable_topographic_profile(300, np.random.uniform(20, 50), np.random.uniform(40, 60))
            start_end = [data[0, 1], data[-1, 1]]  # Extract start and end y-values
            X.append(start_end)
            Y.append(data[:, 1])  # Entire y-profile
        name=uuid.uuid4().hex
        np.save(os.path.join(save_path, f'X_{name}.npy'), np.array(X))
        np.save(os.path.join(save_path, f'Y_{name}.npy'), np.array(Y))

# Example usage
create_dataset(files, samples_per_file, folder)

import numpy as np

# Load the numpy arrays from the provided files
X = np.load('./dataset_chunks/X_842351eb0c1a41adb23c629ffcfa50c6.npy')
Y = np.load('./dataset_chunks/Y_842351eb0c1a41adb23c629ffcfa50c6.npy')

# Inspect the structure of these numpy arrays
X_shape = X.shape
Y_shape = Y.shape
X_dtype = X.dtype
Y_dtype = Y.dtype

X_shape, Y_shape, X_dtype, Y_dtype

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

def plot_samples_with_tables(X, Y, num_samples=5):
    # Set professional styling
    plt.style.use('default')
    plt.rcParams.update({
        'font.family': 'serif',
        'font.serif': ['Times New Roman', 'DejaVu Serif'],
        'font.size': 11,
        'axes.linewidth': 1.2,
        'axes.spines.top': False,
        'axes.spines.right': False,
        'axes.grid': True,
        'grid.alpha': 0.3,
        'grid.linewidth': 0.5,
        'figure.facecolor': 'white'
    })

    # Set up the figure layout - adjusted for square subplots
    fig = plt.figure(figsize=(16, num_samples * 3.2))
    grid = plt.GridSpec(num_samples, 2, width_ratios=[3.5, 1], hspace=0.4, wspace=0.3)

    # Randomly select indices to plot
    np.random.seed(6)  # For reproducibility
    random_indices = np.random.choice(X.shape[0], num_samples, replace=False)

    # Prepare tables
    X_table_data = X[random_indices]
    Y_table_data = [Y[idx][[0, -1]] for idx in random_indices]  # Only the first and last element of each sample
    Y_full_sample_data = Y[random_indices]

    # Create DataFrame for display
    X_df = pd.DataFrame(X_table_data, columns=['X₁', 'X₂'], index=[f'Sample {idx}' for idx in random_indices])
    Y_df = pd.DataFrame(Y_table_data, columns=['First Y', 'Last Y'], index=[f'Sample {idx}' for idx in random_indices])

    # Define constant arrow length for all gradients
    ARROW_LENGTH = 2.4  # Slightly larger for better visibility

    # Plot each sample
    for i, idx in enumerate(random_indices):
        ax = fig.add_subplot(grid[i, 0])
        x_sample = X[idx]
        y_sample = Y[idx]
        x_range = np.linspace(-2, 2, y_sample.size)

        # Plot terrain as solid clean line with professional styling
        ax.plot(x_range, y_sample, color='#2C3E50', linewidth=2.5, alpha=0.9, zorder=2)

        # Plot only the first point as red dot with better styling
        ax.scatter(x_range[0], y_sample[0], color='#E74C3C', s=120,
                  edgecolors='white', linewidth=2, zorder=5, alpha=0.9)

        # Calculate gradient vector from first to last point
        start_point = np.array([x_range[0], y_sample[0]])
        end_point = np.array([x_range[-1], y_sample[-1]])

        # Calculate direction vector and normalize to constant length
        direction = end_point - start_point
        direction_norm = direction / np.linalg.norm(direction)
        arrow_end = start_point + direction_norm * ARROW_LENGTH

        # Draw professional gradient arrow in purple
        ax.annotate('', xy=arrow_end, xytext=start_point,
                   arrowprops=dict(
                       arrowstyle='->',
                       color='#8E44AD',  # Professional purple
                       lw=2.5,
                       alpha=0.8,
                       shrinkA=8,  # Start arrow slightly away from point
                       shrinkB=0
                   ),
                   zorder=4)

        # Set square aspect ratio with professional styling
        ax.set_aspect('equal', adjustable='box')

        # Professional axis styling
        ax.set_xlabel('Distance', fontsize=12, fontweight='medium')
        ax.set_ylabel('Elevation', fontsize=12, fontweight='medium')
        ax.set_title(f'Terrain Sample {idx}', fontsize=13, fontweight='bold', pad=15)

        # Professional grid and spines
        ax.grid(True, alpha=0.3, linestyle='-', linewidth=0.5)
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_linewidth(1.2)
        ax.spines['bottom'].set_linewidth(1.2)

        # Set consistent axis limits to maintain square appearance
        x_range_span = x_range[-1] - x_range[0]
        y_range_span = np.max(y_sample) - np.min(y_sample)
        max_span = max(x_range_span, y_range_span)

        x_center = (x_range[0] + x_range[-1]) / 2
        y_center = (np.min(y_sample) + np.max(y_sample)) / 2

        # Add some padding for better visualization
        padding = max_span * 0.15
        ax.set_xlim(x_center - max_span/2 - padding, x_center + max_span/2 + padding)
        ax.set_ylim(y_center - max_span/2 - padding, y_center + max_span/2 + padding)

        # Professional tick formatting
        ax.tick_params(axis='both', which='major', labelsize=10,
                      direction='out', length=4, width=1.2)

    # Place the X DataFrame in the grid with professional styling
    ax_table_x = plt.subplot(grid[:, 1])
    ax_table_x.axis('off')
    ax_table_x.axis('tight')

    # Create professional table
    table = ax_table_x.table(cellText=X_df.values,
                            colLabels=X_df.columns,
                            rowLabels=X_df.index,
                            cellLoc='center',
                            loc='center')

    # Professional table styling
    table.auto_set_font_size(False)
    table.set_fontsize(10)
    table.scale(1.2, 2.0)

    # Style table cells
    for (i, j), cell in table.get_celld().items():
        if i == 0:  # Header row
            cell.set_text_props(weight='bold', color='white')
            cell.set_facecolor('#34495E')
        elif j == -1:  # Row labels
            cell.set_text_props(weight='bold')
            cell.set_facecolor('#ECF0F1')
        else:  # Data cells
            cell.set_facecolor('white')
        cell.set_edgecolor('#BDC3C7')
        cell.set_linewidth(1)

    ax_table_x.set_title('Input Parameters', fontsize=13, fontweight='bold', pad=20)

    plt.tight_layout()
    plt.show()

    return X_df, Y_df

# Use the function to plot the samples and get the dataframes
X_df, Y_df = plot_samples_with_tables(X, Y)

import numpy as np
import matplotlib.pyplot as plt
import os

def load_and_visualize_data(folder, num_plots=None):
    # List all .npy files
    files = os.listdir(folder)
    X_files = sorted([file for file in files if file.startswith('X_')])
    Y_files = sorted([file for file in files if file.startswith('Y_')])

    # Ensure that the number of plots does not exceed the number of available file pairs
    if num_plots is not None:
        num_plots = min(num_plots, len(X_files))

    # Load and plot data
    plot_count = 0
    for X_file, Y_file in zip(X_files, Y_files):
        if num_plots is not None and plot_count >= num_plots:
            break  # Stop plotting if the limit is reached

        X = np.load(os.path.join(folder, X_file))
        Y = np.load(os.path.join(folder, Y_file))

        for x, y in zip(X, Y):
            plt.figure(figsize=(10, 5))
            plt.title(f"Topographic Profile Visualization: {X_file} & {Y_file}")
            plt.scatter(np.linspace(-2, 2, len(y)), y, alpha=0.1)  # Full profile

            plt.scatter([-2, 2], x, color='red', label='Start-End Conditions')  # Start and end points
            plt.legend()
            plt.xlabel("Normalized X")
            plt.ylabel("Normalized Y")
            plt.show()
            plot_count += 1  # Increment the plot count

            if num_plots is not None and plot_count >= num_plots:
                break  # Stop plotting if the limit is reached

# Example usage
load_and_visualize_data('./dataset_chunks', num_plots=8)

"""# Define Model"""

import tensorflow as tf
from tensorflow.keras import layers, Model
from tensorflow.keras.layers import Input, Dense, Lambda, Concatenate, Reshape, Flatten
from tensorflow.keras.models import Model
import numpy as np
from tqdm import tqdm

def sampling(args):
    """Reparameterization trick by sampling from an isotropic unit Gaussian."""
    z_mean, z_log_var = args
    batch = tf.shape(z_mean)[0]
    dim = tf.shape(z_mean)[1]
    epsilon = tf.random.normal(shape=(batch, dim))
    return z_mean + tf.exp(0.5 * z_log_var) * epsilon

# Encoder
def create_encoder():
    inputs = Input(shape=(300,))  # input is the full profile
    condition = Input(shape=(2,))  # start and end points
    x = Concatenate()([inputs, condition])
    x = Dense(512, activation='relu')(x)
    x = Dense(256, activation='relu')(x)
    z_mean = Dense(200)(x)
    z_log_var = Dense(200)(x)
    z = Lambda(sampling, output_shape=(200,))([z_mean, z_log_var])
    encoder = Model([inputs, condition], [z_mean, z_log_var, z], name='encoder')
    encoder.summary()
    return encoder

# Decoder
def create_decoder():
    latent_inputs = Input(shape=(200,))
    condition = Input(shape=(2,))
    x = Concatenate()([latent_inputs, condition])
    x = Dense(256, activation='relu')(x)
    x = Dense(512, activation='relu')(x)
    outputs = Dense(300, activation='linear')(x)
    decoder = Model([latent_inputs, condition], outputs, name='decoder')
    decoder.summary()
    return decoder

encoder = create_encoder()
decoder = create_decoder()

class VAE(Model):
    def __init__(self, encoder, decoder, **kwargs):
        super(VAE, self).__init__(**kwargs)
        self.encoder = encoder
        self.decoder = decoder

    def call(self, inputs):
        condition, profile = inputs
        z_mean, z_log_var, z = self.encoder([profile, condition])
        reconstructed = self.decoder([z, condition])
        # Add KL divergence regularization loss.
        kl_loss = -0.5 * tf.reduce_mean(
            z_log_var - tf.square(z_mean) - tf.exp(z_log_var) + 1)
        self.add_loss(kl_loss)
        return reconstructed

# Instantiate the VAE
vae = VAE(encoder, decoder)
vae.compile(optimizer='adam', loss='mse')

import tensorflow as tf
from tensorflow.keras.utils import plot_model
import os

# First ensure the required visualization libraries are installed
# This code should be run in a terminal/command prompt
# !pip install pydot graphviz

# Create directory for saved visualizations if it doesn't exist
os.makedirs('model_diagrams', exist_ok=True)

# Plot the encoder architecture
plot_model(
    encoder,
    to_file='model_diagrams/encoder_architecture.png',
    show_shapes=True,
    show_layer_names=True,
    expand_nested=True
)

# Plot the decoder architecture
plot_model(
    decoder,
    to_file='model_diagrams/decoder_architecture.png',
    show_shapes=True,
    show_layer_names=True,
    expand_nested=True
)

# Plot the overall VAE architecture
# Note: For the full VAE model, we need to create input layers first
profile_input = tf.keras.layers.Input(shape=(300,))
condition_input = tf.keras.layers.Input(shape=(2,))
vae_model = VAE(encoder, decoder)
reconstructed = vae_model([condition_input, profile_input])
full_model = tf.keras.Model(inputs=[condition_input, profile_input], outputs=reconstructed)

plot_model(
    full_model,
    to_file='model_diagrams/vae_architecture.png',
    show_shapes=True,
    show_layer_names=True,
    expand_nested=True,
    dpi=96
)

print("Model architecture diagrams saved to the 'model_diagrams' directory")

"""# Train Model"""

def load_and_concatenate(folder_path):
    files = os.listdir(folder)
    X_files = sorted([file for file in files if file.startswith('X_')])
    Y_files = sorted([file for file in files if file.startswith('Y_')])
    print(X_files)
    print(Y_files)

    X_all = np.concatenate([np.load(os.path.join(folder_path, file)) for file in X_files])
    Y_all = np.concatenate([np.load(os.path.join(folder_path, file)) for file in Y_files])
    return X_all, Y_all

# Assuming all files are in the 'data' folder
X, Y = load_and_concatenate(folder)
len(X)
len(Y)

from sklearn.model_selection import train_test_split

# Generate dataset with slopes
#X, Y = create_dataset(320)
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2)

# Instantiate and train the VAE
vae = VAE(encoder, decoder)
vae.compile(optimizer='adam', loss='mse')
history = vae.fit([X_train, Y_train], Y_train, epochs=500, batch_size=3000, validation_data=([X_test, Y_test], Y_test))

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker


# Assuming 'history' is your Keras history object from model.fit()
history_dict = history.history
loss_values = history_dict['loss']
val_loss_values = history_dict['val_loss']
epochs = range(1, len(loss_values) + 1)

fig, ax = plt.subplots(figsize=(10, 6))

# Plotting training and validation loss
ax.plot(epochs, loss_values, 'bo-', label='Training Loss', markersize=5, linewidth=2)
ax.plot(epochs, val_loss_values, 'r-', label='Validation Loss', linewidth=2)

# Setting the title and labels
ax.set_title('Model Loss During Training', fontsize=16, fontweight='bold')
ax.set_xlabel('Epochs', fontsize=14)
ax.set_ylabel('Loss', fontsize=14)

# Improving the ticks for better readability
ax.xaxis.set_major_locator(ticker.MaxNLocator(integer=True))  # Ensures only integer values are used for epochs
ax.tick_params(axis='both', which='major', labelsize=12)

# Adding grid lines
ax.grid(True, linestyle='--', linewidth=0.5, color='gray', alpha=0.5)

# Setting the y-axis limit starting from 0.2 and going lower
ax.set_ylim( min(min(loss_values), min(val_loss_values)),0.2)

# Adding a legend outside of the plot area
ax.legend(fontsize=12, loc='upper center', bbox_to_anchor=(0.5, -0.15), fancybox=True, shadow=True, ncol=2)

# Tight layout often produces nicer layouts
plt.tight_layout()

# Save the plot as a high-resolution PNG file
plt.savefig('training_validation_loss.png', format='png', dpi=300)

plt.show()

"""# Test Model"""

import random
import numpy as np
import matplotlib.pyplot as plt

def simple_moving_average(data, window_size):
    # Initialize the moving average array with zeros
    ma = np.zeros_like(data)

    # Compute the moving average only for points where a full window can be applied
    for i in range(window_size - 1, len(data) - window_size + 1):
        ma[i] = np.mean(data[i - window_size + 1:i + 1])

    # For the start and end points where a full window is not available,
    # use the available data to compute the average
    for i in range(window_size - 1):
        ma[i] = np.mean(data[:i + 1])
        ma[-(i + 1)] = np.mean(data[-(i + 2):])

    return ma

def generate_profiles(decoder, num_samples, condition, window_size=5):
    # Set professional styling
    plt.style.use('default')
    plt.rcParams.update({
        'font.family': 'serif',
        'font.serif': ['Times New Roman', 'DejaVu Serif'],
        'font.size': 11,
        'axes.linewidth': 1.2,
        'axes.spines.top': False,
        'axes.spines.right': False,
        'axes.grid': True,
        'grid.alpha': 0.3,
        'grid.linewidth': 0.5,
        'figure.facecolor': 'white'
    })

    if condition is None:
        current_condition = np.random.uniform(-2, 2, (1, 2))
    else:
        current_condition = np.array(condition).reshape(1, 2)

    for i in range(num_samples):
        z_sample = np.random.normal(size=(1, 200))
        generated_profile = decoder.predict([z_sample, current_condition])

        # Ensure the moving average fits at the beginning and end
        generated_profile[0][0] = current_condition[0][0]
        generated_profile[0][-1] = current_condition[0][1]

        # Compute the moving average of the generated profile
        ma_profile = simple_moving_average(generated_profile[0], window_size)

        # Professional plotting setup - smaller, more compact size
        fig, ax = plt.subplots(figsize=(5, 4))  # Smaller, more compact figure

        # Correct the x_values to match the length of the moving average
        x_values = np.linspace(-2, 2, len(ma_profile))

        # Plot raw generated profile with very light styling (background noise)
        ax.scatter(x_values, generated_profile[0],
                  color='#BDC3C7', alpha=0.15, s=8, zorder=1)

        # Plot moving average as main terrain line with professional styling
        ax.plot(x_values, ma_profile, color='#2C3E50', linewidth=2.5,
               alpha=0.9, zorder=2)

        # Plot only the first condition point with professional red styling
        ax.scatter([-2], [current_condition[0][0]], color='#E74C3C', s=120,
                  edgecolors='white', linewidth=2, zorder=5, alpha=0.9)

        # Calculate and draw gradient arrow (purple)
        start_point = np.array([-2, current_condition[0][0]])
        end_point = np.array([2, current_condition[0][1]])

        # Calculate direction vector and normalize to constant length
        direction = end_point - start_point
        direction_norm = direction / np.linalg.norm(direction)
        ARROW_LENGTH = 2.4
        arrow_end = start_point + direction_norm * ARROW_LENGTH

        # Draw professional gradient arrow in purple
        ax.annotate('', xy=arrow_end, xytext=start_point,
                   arrowprops=dict(
                       arrowstyle='->',
                       color='#8E44AD',  # Professional purple
                       lw=2.5,
                       alpha=0.8,
                       shrinkA=8,  # Start arrow slightly away from point
                       shrinkB=0
                   ),
                   zorder=4)

        # Set appropriate aspect ratio for smaller plots
        ax.set_aspect('equal', adjustable='box')

        # Professional axis styling - compact version
        ax.set_xlabel('Distance', fontsize=11, fontweight='medium')
        ax.set_ylabel('Elevation', fontsize=11, fontweight='medium')
        ax.set_title(f'Generated Terrain Profile {i+1}', fontsize=12, fontweight='bold', pad=12)

        # Professional grid and spines
        ax.grid(True, alpha=0.3, linestyle='-', linewidth=0.5)
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_linewidth(1.2)
        ax.spines['bottom'].set_linewidth(1.2)

        # Set consistent axis limits for compact visualization
        x_range_span = x_values[-1] - x_values[0]
        y_range_span = np.max(ma_profile) - np.min(ma_profile)
        max_span = max(x_range_span, y_range_span)

        x_center = (x_values[0] + x_values[-1]) / 2
        y_center = (np.min(ma_profile) + np.max(ma_profile)) / 2

        # Reduced padding for more compact appearance
        padding = max_span * 0.12
        ax.set_xlim(x_center - max_span/2 - padding, x_center + max_span/2 + padding)
        ax.set_ylim(y_center - max_span/2 - padding, y_center + max_span/2 + padding)

        # Professional tick formatting - slightly smaller for compact plots
        ax.tick_params(axis='both', which='major', labelsize=9,
                      direction='out', length=3, width=1.1)

        plt.tight_layout()
        plt.show()


# Example usage
generate_profiles(decoder, 5, condition=[1, -2])

import numpy as np
import matplotlib.pyplot as plt

def simple_moving_average(data, window_size):
    """
    Calculate the simple moving average of the given data.
    """
    ma = np.zeros_like(data)
    # Calculate moving average where a full window is possible
    for i in range(window_size - 1, len(data) - window_size + 1):
        ma[i] = np.mean(data[i - window_size + 1:i + 1])
    # Handle start and end points where a full window isn't available
    for i in range(window_size - 1):
        ma[i] = np.mean(data[:i + 1])
        ma[-(i + 1)] = np.mean(data[-(i + 2):])
    return ma

def generate_sample(decoder, condition, window_size=5):
    """
    Generate a single profile based on the given condition and apply moving average.
    """
    if condition is None:
        current_condition = np.random.uniform(-2, 2, (1, 2))
    else:
        current_condition = np.array(condition).reshape(1, 2)

    z_sample = np.random.normal(size=(1, 200))
    generated_profile = decoder.predict([z_sample, current_condition], verbose=0)

    # Fix the boundaries to match the conditions
    generated_profile[0][0] = current_condition[0][0]
    generated_profile[0][-1] = current_condition[0][1]

    # Calculate the moving average of the generated profile
    ma_profile = simple_moving_average(generated_profile[0], window_size)
    return generated_profile[0], ma_profile, current_condition

def plot_profiles_and_histogram(decoder, num_samples, condition, window_size=5):
    """
    Plot multiple generated profiles, histograms, and highlight the median.
    """
    profiles = [generate_sample(decoder, condition, window_size) for _ in range(num_samples)]
    profiles.sort(key=lambda x: len(x[1]))  # Sorting by length of moving average profile

    # Finding the median sample
    median_index = len(profiles) // 2
    median_profile = profiles[median_index]

    plt.figure(figsize=(10, 5))
    for i, (profile, ma_profile, cond) in enumerate(profiles):
        x_values = np.linspace(-2, 2, len(ma_profile))
        if i == median_index:
            plt.plot(x_values, ma_profile, color='red', label='Median Moving Average')
        else:
            plt.plot(x_values, ma_profile, color='gray', alpha=0.5)

    plt.scatter([-2, 2], median_profile[2][0], color='blue', label='Conditions')
    plt.title("Generated Topographic Profiles")
    plt.legend()
    plt.show()

    # Plotting histograms
    all_profiles = np.array([p[0] for p in profiles])
    plt.figure(figsize=(10, 5))
    plt.hist(all_profiles.ravel(), bins=30, color='gray', alpha=0.5)
    plt.title("Histogram of Profile Values")
    plt.xlabel("Profile value")
    plt.ylabel("Frequency")

    # Calculate percentiles
    p5 = np.percentile(all_profiles, 5)
    p50 = np.percentile(all_profiles, 50)
    p95 = np.percentile(all_profiles, 95)

    plt.axvline(p5, color='green', linestyle='dashed', linewidth=1, label='p5')
    plt.axvline(p50, color='blue', linestyle='dashed', linewidth=1, label='p50')
    plt.axvline(p95, color='red', linestyle='dashed', linewidth=1, label='p95')
    plt.legend()
    plt.show()

# Example usage, assuming 'decoder' is defined
plot_profiles_and_histogram(decoder, 100, condition=[0, 0])

"""# Save Model"""

import datetime

# Get the current date and time
current_time = datetime.datetime.now()

# Format the date and time into a string suitable for a filename
filename = current_time.strftime("vae_model_%Y-%m-%d_%H-%M-%S")
model_folder = f'models/{filename}'

# Use this filename to save the model
vae.save(model_folder)  # Saves the model in the TensorFlow SavedModel format

import zipfile
import os

def zip_directory(folder_path, zip_path):
    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                # Create a relative path for files to keep the directory structure
                relative_path = os.path.relpath(os.path.join(root, file), os.path.join(folder_path, '..'))
                zipf.write(os.path.join(root, file), arcname=relative_path)

# Specify the directory of the SavedModel and the desired output ZIP file path
zip_directory(model_folder, f'{filename}.zip')

"""# Use Training Model"""

def unzip_directory(zip_path, extract_to):
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        zip_ref.extractall(extract_to)

# Specify the path to the ZIP file and the extraction target directory
unzip_directory(f'vae_model_2024-04-29_09-12-06.zip', f'models')

# Load the entire model
loaded_vae = load_model(f'models/vae_model_2024-04-29_09-12-06')
decoder=loaded_vae.decoder

import numpy as np

class ProfileSimulator:
    def __init__(self, decoder, window_size=2):
        """
        Initialize the ProfileSimulator with a decoder model and a window size for moving average.
        """
        self.decoder = decoder
        self.window_size = window_size

    def simple_moving_average(self, data):
        """
        Calculate the simple moving average of the given data.
        """
        ma = np.zeros_like(data)
        # Calculate moving average where a full window is possible
        for i in range(self.window_size - 1, len(data) - self.window_size + 1):
            ma[i] = np.mean(data[i - self.window_size + 1:i + 1])
        # Handle start and end points where a full window isn't available
        for i in range(self.window_size - 1):
            ma[i] = np.mean(data[:i + 1])
            ma[-(i + 1)] = np.mean(data[-(i + 2):])
        return ma

    def generate_sample(self, condition):
        """
        Generate a single profile based on the given condition and apply moving average.
        """
        if condition is None:
            current_condition = np.random.uniform(-2, 2, (1, 2))
        else:
            current_condition = np.array(condition).reshape(1, 2)

        z_sample = np.random.normal(size=(1, 200))
        generated_profile = self.decoder.predict([z_sample, current_condition], verbose=0)

        # Fix the boundaries to match the conditions
        generated_profile[0][0] = current_condition[0][0]
        generated_profile[0][-1] = current_condition[0][1]

        # Calculate the moving average of the generated profile
        ma_profile = self.simple_moving_average(generated_profile[0])
        return ma_profile

    def simulate(self, num_samples, x_coords, condition):
        """
        Simulate multiple profiles and aggregate the results.
        """
        y_profiles = []
        for _ in range(num_samples):
            y = self.generate_sample(condition)
            y_profiles.append(y)

        return x_coords, np.array(y_profiles)


# Example usage, assuming 'decoder' is an instance of a model class
sim = ProfileSimulator(decoder)
x, y = sim.simulate(100, np.linspace(0, 100, 300), condition=[0, 1])
x2, y2 = np.linspace(500, 1500, 52) , np.tile(np.linspace(1, -1, 52), (100, 1))
x3, y3 = sim.simulate(100, np.linspace(1500, 2500, 300), condition=[-1, 0])

import numpy as np
import csv
import matplotlib.pyplot as plt

class ProfileGenerator:
    def __init__(self):
        self.all_x = np.array([])
        self.all_y = np.array([]).reshape(0, 0)
        self.comments = []
        self.reference_points = []

    def add_reference_points(self, x, y, label):
        """
        Add multiple reference points with coordinates (list of x, list of y) and a custom label.
        """
        self.reference_points.append((x, y, label))

    def add_profile_segment(self, x, y, comment="Default"):
        """
        Append a segment to the ongoing profiles.
        """
        if self.all_y.size == 0:  # Check if all_y is empty
            self.all_y = y
            self.all_x = x
            self.comments = [comment] * len(x)
        else:
            # Extend x coordinates
            # Ensure that new x starts right after the last x in all_x
            offset = self.all_x[-1] + (x[0] - self.all_x[-1]) + np.diff(x[:2])[0]
            new_x = x + offset - x[0]
            self.all_x = np.concatenate((self.all_x, new_x))
            # Append new y values to each existing profile
            self.all_y = np.hstack((self.all_y, y))
            # Extend comments
            self.comments.extend([comment] * len(x))

    def interpolate_gaps(self, threshold=40):
        new_x = []
        new_y = []
        new_comments = []

        for i in range(1, len(self.all_x)):
            new_x.append(self.all_x[i-1])
            new_y.append(self.all_y[:, i-1])
            new_comments.append(self.comments[i-1])

            gap = self.all_x[i] - self.all_x[i-1]
            if gap > threshold:
                num_points = int(gap / threshold)
                for j in range(1, num_points):
                    interpolated_x = self.all_x[i-1] + j * threshold
                    interpolated_y = self.all_y[:, i-1] + (self.all_y[:, i] - self.all_y[:, i-1]) * (j / num_points)
                    noise = np.random.normal(0, 0.01, size=self.all_y[:, i-1].shape)
                    interpolated_y += noise
                    new_x.append(interpolated_x)
                    new_y.append(interpolated_y)
                    new_comments.append("Interpolated")

        new_x.append(self.all_x[-1])
        new_y.append(self.all_y[:, -1])
        new_comments.append(self.comments[-1])

        self.all_x = np.array(new_x)
        self.all_y = np.array(new_y).T
        self.comments = new_comments

    def plot_profiles(self, vertical_exaggeration=1.0, figsize=(10, 5)):
        """
        Plot all profiles with P5, P50, and P95 highlighted along with the average as a red dotted line.
        """
        plt.figure(figsize=figsize)
        lengths = np.array([np.sum(np.sqrt(np.diff(self.all_x)**2 + np.diff(profile)**2)) for profile in self.all_y])
        percentiles = np.percentile(lengths, [5, 50, 95])

        average_profile = np.mean(self.all_y, axis=0)

        for profile in self.all_y:
            plt.plot(self.all_x, profile * vertical_exaggeration, color='gray', alpha=0.5)

        for x, y, label in self.reference_points:
            plt.scatter(x, y, label=label, zorder=2)

        # Plot percentile profiles
        for index, percentile in enumerate(percentiles):
            percentile_color = ['blue', 'red', 'green'][index]
            percentile_style = 'dotted'
            percentile_profile = self.all_y[np.argmin(np.abs(lengths - percentile))]
            plt.plot(self.all_x, percentile_profile * vertical_exaggeration, linestyle=percentile_style, color=percentile_color, label=f'P{[5, 50, 95][index]}')

        # Plot the average profile
        plt.plot(self.all_x, average_profile * vertical_exaggeration, color='orange', linewidth=2, label='Average Profile')


        plt.title("Continuous Extended Profiles with Percentiles Highlighted")
        plt.xlabel("X Coordinates")
        plt.ylabel("Profile Values (Exaggerated)" if vertical_exaggeration != 1 else "Profile Values")
        plt.legend()
        plt.show()

    def plot_length_histogram(self):
        """
        Plot a histogram of the total lengths of all profiles.
        """
        lengths = np.array([np.sum(np.sqrt(np.diff(self.all_x)**2 + np.diff(profile)**2)) for profile in self.all_y])
        plt.figure(figsize=(10, 5))
        plt.hist(lengths, bins=30, color='gray', alpha=0.7)
        percentiles = np.percentile(lengths, [5, 50, 95])
        for perc, color, label in zip(percentiles, ['blue', 'red', 'green'], ['P5', 'P50', 'P95']):
            plt.axvline(perc, color=color, label=f'{label} ({perc:.2f})')
        plt.title("Histogram of Total Lengths of Extended Profiles")
        plt.xlabel("Total Length")
        plt.ylabel("Frequency")
        plt.legend()
        plt.show()


    def export_profiles(self, filename):
        """
        Export all profiles into a CSV file.
        Each profile is saved in a separate column with corresponding x-coordinates.
        """
        df = pd.DataFrame(self.all_y.T, columns=[f'Profile {i+1}' for i in range(self.all_y.shape[0])])
        df['X Coordinates'] = self.all_x
        df = df[['X Coordinates'] + [f'Profile {i+1}' for i in range(self.all_y.shape[0])]]

        if self.comments:
            df['Comments'] = self.comments

        df.to_csv(filename, index=False)

    def export_reference_points(self, filename):
        """
        Export all reference points into a CSV file.
        """
        with open(filename, 'w', newline='') as csvfile:
            csvwriter = csv.writer(csvfile)
            csvwriter.writerow(['X', 'Y', 'Label'])
            for x, y, label in self.reference_points:
                for i in range(len(x)):
                    csvwriter.writerow([x[i], y[i], label])

    def print_percentile_profiles(self):
        lengths = np.array([np.sum(np.sqrt(np.diff(self.all_x)**2 + np.diff(profile)**2)) for profile in self.all_y])
        percentiles = np.percentile(lengths, [5, 50, 95])
        indices = [
            np.argmin(np.abs(lengths - percentiles[0])),
            np.argmin(np.abs(lengths - percentiles[1])),
            np.argmin(np.abs(lengths - percentiles[2]))
        ]
        for idx, perc in zip(indices, ['P5', 'P50', 'P95']):
            print(f"{perc} Profile: Profile {idx + 1}, Length: {lengths[idx]:.2f}")

# Example usage
generator = ProfileGenerator()
generator.add_profile_segment(x, y, "first")
generator.add_profile_segment(x2, y2, "stab")
generator.add_profile_segment(x3, y3, "last")

generator.add_reference_points(x2, y2[0], "stab")

generator.interpolate_gaps(threshold=40)

generator.plot_profiles()  # To visualize profiles and percentiles
generator.plot_length_histogram() # To visualize histogram of profile lengths
generator.export_profiles('profiles.csv')
#generator.export_reference_points('references.csv')
generator.print_percentile_profiles()

def transform_y(y, original_start, original_end, new_start, new_end):
    # Convert scalar parameters to arrays if necessary
    if np.isscalar(original_start):
        original_start = np.full(len(y), original_start)
    if np.isscalar(original_end):
        original_end = np.full(len(y), original_end)
    if np.isscalar(new_start):
        new_start = np.full(len(y), new_start)
    if np.isscalar(new_end):
        new_end = np.full(len(y), new_end)

    # Initialize an array to store the transformed profiles
    transformed_y = np.zeros_like(y)

    # Process each sample individually
    for i in range(len(y)):
        scale_y = (new_end[i] - new_start[i]) / (original_end[i] - original_start[i])
        translate_y = new_start[i] - original_start[i] * scale_y
        transformed_y[i] = y[i] * scale_y + translate_y

    return transformed_y

def simulation(s, f, t, ff, tt, con, n_sims):
  x, y = s.simulate(n_sims, np.linspace(f, t, 300), condition=con)
  return x , transform_y(y,con[0],con[1],ff,tt)

def find_y_at_x(x, y, target_x):
    if np.isscalar(target_x):
        # If target_x is a single number, find the closest x and return corresponding y values
        idx = np.abs(x - target_x).argmin()  # Find the index of the closest x value
        return y[:, idx]  # Return all y values at this index
    else:
        # If target_x is an array, find the closest x for each element and return corresponding y values
        idxs = np.array([np.abs(x - tx).argmin() for tx in target_x])
        return y[:, idxs]  # Return all y values at these indices

def add_range(f,t,data, n_sims=10):
    # Extract the x and y components
    data_np = np.array(data)

    x = data_np[:, 0]
    y = data_np[:, 1]

    # Filter based on the x_range
    mask = (x >= f) & (x <= t)
    x_filtered = x[mask]
    y_filtered = y[mask]

    return x_filtered, np.tile(y_filtered, (n_sims, 1))

def to_data(x, y):
    if len(x) != len(y):
        raise ValueError("The x and y arrays must have the same length.")
    data_tuples = list(zip(x, y))

    return data_tuples

def normalize_vector(v):
    norm = np.sqrt(v[0]**2 + v[1]**2)
    return (v[0] / norm, v[1] / norm) if norm != 0 else (0, 0)

def interpolate(sim, f, t, data1, data2, distance1, distance2, condition=[-1, 1], n_sims=10, offset=0):

    if np.isscalar(data1):
        x1 = data2[:, 0] if isinstance(data2, np.ndarray) else np.array(data2)[:, 0]
        y1 = np.full_like(x1, data1)
    elif isinstance(data1, np.ndarray) and data1.ndim == 1:
        x1 = data2[:, 0] if isinstance(data2, np.ndarray) else np.array(data2)[:, 0]
        y1 = np.tile(data1, (len(x1), 1))
    else:
        data1_np = np.array(data1)
        x1 = data1_np[:, 0]
        y1 = data1_np[:, 1]

    if np.isscalar(data2):
        x2 = data1[:, 0] if isinstance(data1, np.ndarray) else np.array(data1)[:, 0]
        y2 = np.full_like(x2, data2)
    elif isinstance(data2, np.ndarray) and data2.ndim == 1:
        x2 = data1[:, 0] if isinstance(data1, np.ndarray) else np.array(data1)[:, 0]
        y2 = np.tile(data2, (len(x2), 1))
    else:
        data2_np = np.array(data2)
        x2 = data2_np[:, 0]
        y2 = data2_np[:, 1]

    if np.isscalar(distance1):
        distance1 = np.full_like(x1, distance1)
    if np.isscalar(distance2):
        distance2 = np.full_like(x2, distance2)

    # Filtering both datasets
    mask1 = (x1 >= f) & (x1 <= t)
    mask2 = (x2 >= f) & (x2 <= t)

    common_x = np.intersect1d(x1[mask1], x2[mask2])
    first_idx1 = np.where(x1 == common_x[0])[0][0]
    first_idx2 = np.where(x2 == common_x[0])[0][0]
    last_idx1 = np.where(x1 == common_x[-1])[0][0]
    last_idx2 = np.where(x2 == common_x[-1])[0][0]

    xf, yf = simulation(sim, 0, distance1[first_idx1]+distance2[first_idx2], y1[first_idx1], y2[first_idx2], condition, n_sims)
    xl, yl = simulation(sim, 0, distance1[last_idx1]+distance2[last_idx2], y1[last_idx1], y2[last_idx2], condition, n_sims)


    interpolated_y = []
    for x_val in common_x:
        idx1 = np.where(x1 == x_val)[0][0]
        idx2 = np.where(x2 == x_val)[0][0]
        fraction = (x_val - common_x[0]) / (common_x[-1] - common_x[0])
        yff=find_y_at_x(xf,yf,distance1[idx1])-y1[first_idx1]+y1[idx1]
        yll=find_y_at_x(xl,yl,distance1[idx1])-y1[first_idx1]+y1[idx1]
        interpolated_y.append(fraction*(yll-yff)+yff+offset)


    return common_x, np.array(interpolated_y).T

def to_xy(data, n_sims):
    """
    Extracts the x and y components from a specified segment of the segmented data.

    Parameters:
        segmented_data (dict): A dictionary containing segmented data.
        segment_key (str): The key for the segment to extract data from.
        index (int): The index of the data in the segment to process.

    Returns:
        tuple: A tuple containing two numpy arrays, the x and y components.
    """
    data_np = np.array(data)
    x = data_np[:, 0]
    y = data_np[:, 1]
    y = np.tile(y, (n_sims, 1))
    return x, y

n_sims=10
x, y = simulation(sim, 0, 10300, 650, [700,300,400,200,300,700,300,400,200,300], [-2, 2], n_sims)

p1_data = to_data(np.array([2000,2500,3000]), np.array([500,600,700]))
p2_data = to_data(np.array([2000,2500,3000]), np.array([400,400,400]))
x2, y2 = interpolate(sim,2000,3000,p1_data,p2_data,200,200, condition=[-2, 2], n_sims=10)

generator = ProfileGenerator()
generator.add_profile_segment(x2, y2)
generator.plot_profiles()

p1_data = to_data(np.array([2000,2500,3000]), np.array([500,600,700]))
p2_data = to_data(np.array([2000,2500,3000]), np.array([400,400,400]))
x2, y2 = interpolate(sim,2000,3000,p1_data,p2_data,np.array([500,150,0]),200, condition=[-2, 2], n_sims=10)

generator = ProfileGenerator()
generator.add_profile_segment(x2, y2)
generator.plot_profiles()

n_sims=100
x, y = simulation(sim, 0, 10300, 650, [700,300,400,200,300,700,300,400,200,300], [-2, 2], n_sims)
generator = ProfileGenerator()
generator.add_profile_segment(x, y)
generator.plot_profiles()

n_sims=10
x, y = simulation(sim, 0, 10300, 650, 707.288689552, [-2, 2], n_sims)
#seccion 1
x2 =  np.array([10300,10320,10340,10360,10380,10400,10420,10440,10460,10480,10500,10520,10540,10560,10580,10600,10620,10640,10660,10680,10700,10720,10740,10760,10780,10800,10820,10840,10860,10880,10900,10920,10940,10960,10980,11000,11020,11040,11060,11080,11100,11120,11140,11160,11180,11200,11220,11240,11260,11280,11300,11320,11340,11360,11380,11400,11420,11440,11460,11480,11500,11520,11540,11560,11580,11600,11620,11640,11660,11680,11700,11720,11740,11760,11780,11800,11820,11840,11860,11880,11900,11920,11940,11960,11980,12000,12020,12040,12060,12080,12100,12120,12140,12160,12180,12200,12220,12240,12260,12280,12300,12320,12340,12360,12380,12400,12420,12440,12460,12480,12500,12520,12540,12560,12580,12600,12620,12640,12660,12680,12700,12720,12740,12760,12780,12800,12820,12840,12860,12880,12900,12920,12940,12960,12980,13000,13020,13040,13060,13080,13100,13120,13140,13160,13180,13200,13220,13240,13260,13280,13300,13320,13340,13360,13380,13400,13420,13440,13460,13480,13500,13520,13540,13560,13580,13600,13620,13640,13660,13680,13700,13720,13740,13760,13780,13800,13820,13840,13860,13880,13900,13920,13940,13960,13980,14000,14020,14040,14060,14080,14100,14120,14140,14160,14180,14200,14220,14240,14260,14280,14300,14320,14340,14360,14380,14400,14420,14440,14460,14480,14500,14520,14540,14560,14580,14600,14620,14640,14660,14680,14700,14720,14740,14760,14780,14800,14820,14840,14860,14880,14900,14920,14940,14960,14980,15000,15020,15040,15060,15080,15100,15120,15140,15160,15180,15200,15220,15240,15260,15280,15300,15320,15340,15360,15380,15400,15420,15440,15460,15480,15500,15520,15540,15560,15580,15600,15620,15640,15660,15680,15700,15720,15740,15760,15780,15800,15820,15840,15860,15880,15900,15920,15940,15960,15980,16000,16020,16040,16060,16080,16100,16120,16140,16160,16180,16200,16220,16240,16260,16280,16300])
y2 = np.array([707,706,705,706,705,706,706,708,707,707,707.128638088,707.571138939999,706.8394273,706.490435844999,705.819673973,705.779471613,705.591119078,705.229501507,704.885122623,704.030024640999,703.377518873999,703.174287023,702.460740501,701.922940843999,701.861339361999,700.462737988999,700.886349162999,700.309672343999,700.679149932999,700.467143727,700.541517652,700.203779424999,699.572702681999,698.890492271999,698.916496748999,698.754490798,697.738146633,697.571171697999,697.785766928,696.877221317,696.380495851999,696.091159476,695.829896461999,695.20982243,695.276055588999,695.183687759999,694.453429738999,694.517119437,693.877286216,693.00283835,693.591710852,692.690300982,692.200989879999,691.707496022999,692.185419352,692.23177682,691.364743044999,691.081712999,691.285018018999,691.431506465999,690.642835933,689.998645947,689.847791390999,689.543680663,689.150571887999,688.345080273,689.243025994,688.377063871,688.356090221,688.245040681999,688.431608597,687.805895207,687.677547871999,687.151900200999,687.114921697999,686.771902178999,686.828039946999,686.378757739999,685.455535928,685.068812811,684.222282894,684.129834845999,684.028935741,683.85482892,683.107431319,682.774957797999,682.777728630999,682.15366472,682.399614093999,682.570620469,681.404926615,681.251679700999,681.215674059999,680.534887784,680.675941637,680.110076691,680.15907756,679.457665337999,679.212173374,679.100023208,678.851774700999,678.525636225999,677.744864632,678.256089047,677.786517835,677.750467715,676.950565601999,676.787934233999,676.221648268999,675.476132379999,675.035108254999,675.241507423,674.871142200999,674.217738887999,674.153612072999,673.947429375999,673.562875511,673.321767277,673.178209917999,672.380523545999,672.050148924,671.553950594999,671.346125886999,671.204418199999,671.160552920999,670.421642122999,670.236257094,670.296907176999,670.421570893999,670.007617172999,669.053557321999,669.345337984,669.417821957,669.552688967999,670.405671279999,670.121037892999,669.605396495,669.90928664,670.075002889999,670.823861609,671.204930912,669.956795563,670.56747369,670.812599189,670.506131839999,670.503346333999,669.318702596999,669.487035645999,669.093785003999,669.207299484,668.390442173999,667.883261649,667.738906071999,667.541062563999,666.772334795999,666.704939723,666.431501350999,666.314547164,666.225595771,666.066408213,665.362571187999,665.136100357,664.885960933999,664.706902238999,664.289527220999,664.614595936,664.197065392,664.166724313,664.288196652,664.787700137999,664.739533564999,664.940555198999,664.540084772999,664.153598550999,664.152828633,663.827167024,663.024706142,663.121386539,662.846673616999,662.963529694,663.659359558999,663.129757788,663.329574434,663.111586846,663.380450288,662.977206414999,661.446308352999,660.528466077999,660.498254814999,660.24342242,659.359967722999,659.068678934999,658.870468320999,658.393741246999,657.968554701,658.199916162,658.180153905999,657.118766283,657.581516151999,658.254575515,659.002531237999,660.258070231,660.146593292,659.468843447,658.837223279999,658.531779118,657.6255757,658.195153402999,657.980608724,656.979976273,656.677603600999,656.000564221999,656.427345238,656.447427190999,656.865281838999,656.097324552,654.835164041999,653.789399284999,652.872761672,652.817453819999,652.867138824999,653.258611550999,652.634951083,651.989726034999,652.334532167,653.182484904,653.061499363,652.97485713,652.384410101999,652.609492369,653.24479753,653.754484466,655.683119604,655.407275872,655.793187923,655.682710397,655.648589455999,655.259268722999,655.329673945999,654.88808973,654.299893765999,654.50032205,654.128735332,653.687365917999,653.372146055,653.373415421999,653.190274749999,653.100141751,653.317013573,652.740381587999,652.804690015999,652.166022278,652.013248492,652.135688312999,652.052287435,650.941745906,650.515328016,650.088625266,650.492667233,649.92569833,650.232174344999,649.943088444999,649.093863144,649.068218065999,648.287333104,647.584052696999,647.157935525999,646.714374309,646.798467022999,645.665171052999,644.990416158,644.551181119,643.558644006,643.577428671,642.793082843999,642.322370408999,642.004452454999,641.775059154,640.862219290999,640.213852144,640.082383163,639.503896234999,639.047523085999,638.475797372999,638.482291584999,637.735641216999,637.909491842999,637.515985361,637.364438195,637.81345694,637.417195105,637.124615157999,637.686824238999,637.633815664,637.701677844999,637.809982424,638.153145608,638.518657737,638.685055760999,638.627114090999,638.116753854999])
y2 = np.tile(y2, (n_sims, 1))

x3, y3 = simulation(sim, 16300, 30940, 638.116753854999, 420, [2, -2], n_sims)

#seccion 1
xf = np.array([30940,30960,30980,31000,31020,31040,31060,31080,31100,31120,31140,31160,31180,31200,31220,31240,31260,31280,31300,31320,31340,31360,31380,31400,31420,31440,31460,31480,31500,31520,31660,31680,31720,31740,31760,31820,31840,32260,32280,32300,32320,32340,32360,32380,32400,32420,32440,32460,32480,32500,32520,32540,32560,32580,32600,32620,32640,32660,32680,32700,32720,32740,32760,32780,32800,32820,32840,32860,32880,32900,32920,32940,32960,32980,33000,33020,33040,33060,33080,33100,33120,33140,33160,33180,33200,33220,33240,33260,33280,33300,33320,33340,33360,33380,33400,33420,33440,33460,33480,33500,33520,33540,33560,33580,33600,33620,33640,33660,33680,33700,33720,33740,33760,33780,33800,33820,33840,33860,33880,33900,33920,33940,33960,33980,34720,34740,34760,34780,34800,34820,34840,34880,34900,34920,34940,34960,34980,35000,35020,35040,35140,35160,35180,35200,35220,35240,35260,35280,35300,35320,35340,35360,35380,35400,35420,35440,35460,35480,35500,35520,35540,35560,35580,35600,35620,35640,35660,35680,35700,35720,35740,35760,35780,35800,35820,35840,35860,35880,35900,35920,35940,35960,35980,36000,36020,36040,36060,36080,36100,36120,36140,36160,36180,36200,36220,36240,36260,36280,36300,36320,36340,36360,36380,36400,36420,36440,36460,36480,36500,36520,36540,36620,36640,36660,36680,36760,36780,36800,36820,36840,36860,36880,36900,36920,36940,36960,36980,37000,37020,37040,37060,37080,37100,37120,37140,37160,37180,37200,37220,37240,37260,37280,37300,37320,37340,37360,37380,37400,37420,37440,37460,37480,37500,37520,37540,37560,37580,37600,37620,37640,37660,37680,37700,37720,37740,37760,37780,37800,37820,37840,37860,37880,37900,37920,37940,37960,37980,38000,38020,38040,38060,38080,38100,38120,38140,38160,38180,38200,38220,38240,38260,38280,38300,38320,38340,38360,38380,38400,38420,38440,38460,38480,38500,38520,38540,38560,38580,38600,38620,38640,38660,38680,38700,38720,38740,38760,38780,38800,38820,38840,38860,38880,38900,38920,38940,38960,38980,39000,39020,39040,39060,39080,39100,39120,39140,39160,39180,39200,39220,39240,39260,39280,39300,39320,39340,39360,39380,39400,39420,39440,39460,39480,39500,39520,39540,39560,39580,39600,39620,39640,39660,39680,39700,39720,39740,39760,39780,39800,39820,39840,39860,39880,39900,39920,39940,39960,39980,40000,40020,40040,40060,40080,40100,40120,40140,40160,40180,40200,40220,40240,40260,40280,40300,40320,40340,40360,40380,40400,40420,40440,40460,40480,40500,40520,40540,40560,40580,40600,40620,40640,40660,40680,40700,40720,40740,40760,40780,40800,40820,40840,40860,40880,40900,40920,40940,40960,40980,41000,41020,41040,41060,41080,41100,41120,41140,41160,41180,41200,41220,41240,41260,41280,41300,41320,41340,41360,41380,41400,41420,41440,41460,41480,41500,41520,41540,41560,41580,41600,41620,41640,41660,41680,41700,41720,41740,41760,41780,41800,41820,41840,41860,41880,41900,41920,41940,41960,41980,42000,42020,42040,42060,42080,42100,42120,42140,42160,42180,42200,42220,42240,42260,42280,42300,42320,42340,42360,42380,42400,42420,42440,42460,42480,42500,42520,42540,42560,42580,42600,42620,42640,42660,42680,42700,42720,42740,42760,42780,42800,42820,42840,42860,42880,42900,42920,42940,42960,42980,43000,43020,43040,43060,43080,43100,43120,43140,43160,43180,43200,43220,43240,43260,43280,43300,43320,43340,43360,43380,43400,43420,43440,43460,43480,43500,43520,43540,43560,43580,43600,43620,43640,43660,43680,43700,43720,43740,43760,43780,43800,43820,43840,43860,43880,43900,43920,43940,43960,43980,44000,44020,44040,44060,44080,44100,44120,44140,44160,44180,44200,44220,44240,44260,44280,44300,44320,44340,44360,44380,44400,44420,44440,44460,44480,44500,44520,44540,44560,44580,44600,44620,44640,44660,44680,44700,44720,44740,44760,44780,44800,44820,44840,44860,44880,44900,44920,44940,44960,44980,45000,45020,45040,45060,45080,45100,45120,45140,45160,45180,45200,45220,45240,45260,45280,45300,45320,45340,45360,45380,45400,45420,45440,45460,45480,45500,45520,45540,45560,45580,45600,45620,45640,45660,45680,45700,45720,45740,45760,45780,45800,45820,45840,45860,45880,45900,45920,45940,45960,45980,46000,46020,46040,46060,46080,46100,46120,46140,46160,46180,46200,46220,46240,46260,46280,46300,46320,46340,46360,46420,46440,46660,46700,47000])
yf = np.array([419.625564183999,420.196066312,420.368296638,420.232767293999,420.333406194,420.195933276999,420.570901578,420.491580915999,421.027822109999,420.72131042,420.564229054,420.851662820999,421.084835365999,421.434185302,421.171388514999,420.744867996999,421.104821961,421.468001531,420.826141971,420.520446757999,420.65084364,420.846585677,420.780866057,421.148072699,421.471119314,421.263641977,420.883341746999,421.049443127,421.241445254999,421.077648429,419.559267981999,420.015206497999,419.387068923,419.52104501,420.046826182,420.021494905999,420.100880913,421.698466083,421.848517791,421.913080981,421.792349951999,421.868708141,421.74960204,422.041566551,422.393717289999,422.225508643,422.568000982999,422.770006113,422.901395153999,422.47952155,422.492181121999,422.303871367999,422.656407146999,422.590135121999,422.417532732999,422.554405777999,422.5383886,423.068183136,423.081015889,422.807056241999,423.038372125,423.193710366,423.723673926,423.500754965999,423.976866372,423.956458751,424.15079234,424.238497132,424.839914783999,424.403782085999,425.119297334,424.832764788,424.685226665,424.679206798999,424.715381734,424.730900541999,424.55750956,424.826649658999,424.756135546999,424.9886516,425.336906714,425.385113558999,425.689033907999,425.438437415999,425.461357323,425.439516841999,425.401002656,425.660328633,425.983538168999,425.379879744999,425.227057988,425.742022072999,425.357900233999,425.52699665,425.529778344,425.611466598999,425.866306451,425.650730909999,425.988437424999,425.959073725999,426.165526769999,426.607174172999,426.258036139,426.506552403999,426.758994558999,427.310473452999,427.13981264,427.789176703999,428.536459175999,428.629985208999,429.047913149,429.399885917,429.149211749,429.614405940999,429.56916959,429.877445872,429.948426308,430.321373944,431.050463239,430.752259082,430.963306776,431.551966041,431.531408897999,431.605518361999,439.362985856,439.307295206999,439.775063653,440.156783815999,440.503043323999,441.002947103999,440.98082661,441.442893842999,441.333635255999,441.901362741,441.991924881999,442.005745666999,442.639510361,443.164591879,443.501575925999,443.449230069999,444.187775407,444.356666167,444.221745952999,444.502812984999,444.642862660999,444.848762868999,444.449507735999,444.422714717,444.707500057,445.093995257,445.411510388,445.850269848999,446.087794815999,446.266355802,446.395821348,446.72378392,447.060244102,447.077866545999,447.439886563,447.470830467999,447.949042239999,448.257559074,448.567656898999,448.885120839,449.008827778,449.404759669999,449.299062778,449.471451801999,449.508524319999,449.703221287,449.774219803999,450.167598756,449.982509644999,449.981394973,449.928011244999,449.905623991,449.774936442,449.912876541999,450.046886805999,450.09952349,450.035644197,449.987013047,450.422903514999,450.890622328,450.855966527,450.956854351,451.186993706999,451.417965761,451.577198461,451.640591715,451.695540916,451.973644334,451.897223972999,451.848416740999,451.660064384,451.936330641999,452.240353785,452.262044117,452.399392750999,452.653837086,452.589758861999,452.645812578999,452.768094620999,453.114522403,453.386175154999,453.464164159,453.760663656,453.855997093999,453.837423155,453.932020077999,453.747745623,453.401943429,453.504961938999,453.552643407999,453.46495833,452.723354042999,453.337219045999,454.736401435,455.788987314999,456.215519416999,456.364597872999,456.292347432999,456.41688734,456.523866800999,456.431651277,456.176734221999,455.846532532,456.206755703999,455.982301127,456.12624224,455.960286881999,456.265690791999,456.40088415,456.503328995999,456.77246212,456.488989738999,456.608772203999,456.559718202999,456.533468373999,456.369307311999,456.598920318,456.821694143,456.945185308,457.019155098999,457.29303785,457.492554857,457.687984867,458.089574197999,457.851054321999,458.316642243999,458.460553247,458.64781245,459.020951303,459.092998186999,458.954408576999,458.849414512999,458.797384566999,458.777797109,458.698332331,458.783194784999,459.029698618999,459.370283337999,459.294125816,459.586457699999,459.781818057,459.740103884999,459.943629192,460.184334347,459.900455224999,459.776804907999,459.845457794,460.127405383999,460.324840913999,460.698886732999,460.708775412,461.358646223999,460.990718145,461.293851247,461.536969702,461.881005345,462.325101083999,462.820327252,463.281846642999,463.621515138,464.058946132,464.047822891,463.890858677999,463.575322758,463.7470078,463.937876456,463.844454513,464.265845582999,464.435907158,464.827179043,464.969048706,465.971749932,466.388120865,466.530611437999,466.465446520999,466.801274292,466.536113227999,467.215099205999,467.101474408999,467.073163715,467.167727521,467.080714361999,467.275453991999,467.075017738999,466.751401403999,467.182044372999,467.479049937,467.345317205,467.033947631999,466.938728792,467.30222336,467.206146763999,467.311527049,467.368664604,467.553618326999,467.855680913,468.192802481,468.493597308,468.667362534999,469.107322914,469.033112804999,469.162426869999,469.71681718,469.999256187,470.051564675,470.132297452999,470.317919279,470.515052319999,470.857122036,470.792767727,470.863719022999,470.906466751999,471.226882768999,471.030355467999,471.147820341999,471.384106979,471.408385781999,471.268202587,471.294756000999,470.919012935,471.054245025,471.498554418,471.753131316999,472.135626527999,472.337765078,472.378324842999,472.961089931999,472.970645122,473.082488996999,473.163941265999,473.678437506,473.818334838999,473.630347875999,474.113591143,473.895846687,473.998900666999,474.236775776,474.429658147999,474.512440554,474.552870516999,474.988658288,474.385688959999,474.917443579999,474.674736581999,474.828506161999,474.643327901,474.862143818999,474.900717713999,475.214397659999,475.347630942,475.204453558,475.680110575,475.746541185,475.74611592,475.711629447999,476.058579198,476.155864953999,476.20645781,476.492047314999,476.343935638999,476.757722403999,477.092096404,477.349547729999,477.387187531999,477.473349053999,477.154981856,477.015829107999,477.114037456999,477.295301956,477.513036434,477.858596135,478.16236491,478.369837372999,478.626869273,479.02862707,479.175765343,479.487080419999,479.991757469999,480.261112032,480.469731669999,481.471435772,481.587059784,481.530588204,481.463506917,481.783674533,482.335215167,482.705986715999,483.163181414999,483.573203087,483.759228034999,484.003122775,484.204184296999,484.584855491999,484.912565459,484.632398059,484.723705973999,485.104286931999,485.216820165,485.290202199,485.645369026,485.798404226,486.143425622999,485.930997859,486.475354772999,486.136777365,486.118112651999,486.509921287999,486.935231546,486.324128823,486.958639182,486.786581158999,486.856020334999,487.060822943999,487.033712854999,487.205009180999,487.429400497,487.584919646,487.957039278,488.206593091,488.434984464,488.574959638999,488.697787312999,488.589828479,488.905019406,488.876291282,488.867516244999,489.034342317999,489.416056098,489.811076904,489.704500778,489.679892073,489.502005479999,489.899577911999,490.244129348,490.473508870999,490.721196845999,491.215787924999,490.77954954,490.720540407999,491.511687831,491.187478047,491.428203358,491.331560856999,491.069876858999,491.530323378999,492.109110258999,492.397603901,492.124792367999,492.390019672999,492.842220082999,492.775307632,493.101187881999,493.008602009,492.941920976999,493.089205999,493.152403358,493.16322821,493.407248316999,493.61396537,493.513985664,493.632328555,494.244731559999,494.007501095999,494.356578972,494.265274275,494.373620023999,494.966500676999,495.033214023,495.329955220999,495.17154302,495.294129840999,495.553471913,495.612564136,495.699564400999,495.909655165999,496.287675248,496.728985742,496.798776861,496.546426912,496.869734264999,496.944290358999,496.921539306,497.468764812,497.670618018,497.75999838,497.82716741,498.249859894999,498.277047981,498.502635457999,498.174597285,498.084553667,498.775212294,498.778379911999,499.231508553,499.469104515,499.816385405999,500.215503048,500.028405938999,499.845595944,500.306214866,500.299901464,500.663503897999,500.696484571999,501.289018278,500.479297207,500.847037101,500.840702008999,500.609430972999,501.386809837999,501.31739749,501.950184087,502.524122469,502.302877023999,502.367844885,502.486205014999,502.391742012,502.421263511,502.525251793999,502.651550215999,502.990336663999,503.390397769999,503.618742273,503.752236622999,504.275190726999,504.306813872,504.16045278,503.808793422,503.998926118999,503.873062306999,504.325986472,504.167686811999,503.890728750999,504.104203989999,503.767739055999,503.746616513999,503.870083766999,503.889247187,504.377947711999,504.642040027999,504.504375229,504.816702539,505.404949230999,505.60142887,505.455796776999,505.538655295,505.647916477,506.214723585,506.629272553,506.870617343999,506.923714646999,506.685544416,507.038650637999,506.907708447999,507.074322807999,507.351844034,507.876024143999,508.111302222999,508.367009594,507.964460821999,507.948969917999,508.336466495,508.340368483,508.393245467999,508.674482694,508.663167971999,508.592814074999,508.769249976,508.697353701999,508.393318559,508.350821827999,509.081265101999,508.861647156999,508.474890761999,508.785546479999,509.058614282,509.212844725,509.240450765999,509.648113092,509.880838697,509.347697028,509.556656373999,509.614664085,509.897559070999,509.736769913999,509.927730641999,510.155317248,510.378668005999,510.853458108999,511.453558199999,511.332524535999,511.554146245,511.799179220999,511.711641860999,511.989356111999,512.387455075,512.300207105,512.793172977,513.160375303,513.424182195999,513.509283689999,513.884634266,514.26232283,514.488747869,515.465395148999,515.424979828999,515.802690374999,515.86417986,516.123231559,516.432801833999,516.676760708999,516.757466033,517.148992221999,517.443428936,517.562832707999,517.934470465999,518.484634285999,519.254304201999,519.211298897,519.367224440999,519.949196669999,519.864365358999,520.103832488999,521.146897747,521.325296456,521.06804187,521.604391452999,521.870844616999,522.327306098999,522.632447128999,522.281990015,522.950877076999,523.315293657999,523.306624435,523.380229492,523.419461597,523.848476613,524.306126174,524.352645616,525.217164066999,525.391327563,525.375792845999,525.699978207999,525.966479008999,526.678450342,527.069220436,527.741407351,528.11073924,528.669294012,529.234769269,529.572891058999,530.225924172999,530.935163536999,531.485784581999,531.784616429,532.268762682999,532.62863472,532.852887473999,532.985758874999,533.549906347,534.124499634,534.627883887,535.631183995,536.766384657,537.464743463999,538.097694457999,538.56046039,539.026909419,539.673544713999,540.429699752,541.628552768999,541.406471205999,541.736410374,542.655053926,543.89334883,541.417101269999,546.651902135,540.437870681])
yf = np.tile(yf, (n_sims, 1))

x.shape, y.shape, x.dtype, y.dtype
x2.shape, y2.shape, x2.dtype, y2.dtype
x3.shape, y3.shape, x3.dtype, y3.dtype
xf.shape, yf.shape, xf.dtype, yf.dtype

generator = ProfileGenerator()
generator.add_profile_segment(x, y)
generator.add_profile_segment(x2, y2)
generator.add_profile_segment(x3, y3)
generator.add_profile_segment(xf, yf)

generator.plot_profiles()  # To visualize profiles and percentiles

"""# Section"""

import pandas as pd

# Load the CSV file to check its contents
file_path = 'cross-sections_filtrado.csv'
data = pd.read_csv(file_path)

# Split the single column into three separate columns based on the semi-colon delimiter
data_split = data['Length_m;Z;Cross_Sect;DISTANCEFR;DIRECTIONF'].str.split(';', expand=True)

# Rename the new columns appropriately
data_split.columns = ['Length_m', 'Elevation_m', 'Cross_Section', 'DISTANCE FROM S1', 'DIRECTION FROM S1']

# Convert the Length and Elevation columns to numeric types
data_split['Length_m'] = pd.to_numeric(data_split['Length_m'], errors='coerce')
data_split['Elevation_m'] = pd.to_numeric(data_split['Elevation_m'], errors='coerce')

# Sort the data by Cross_Section and Length_m to ensure correct ordering
data_sorted = data_split.sort_values(by=['Cross_Section', 'Length_m'])

# Function to create segments based on the spacing of 20 meters
def create_segments(data):
    segments = {}
    current_segment = []
    last_length = None

    for index, row in data.iterrows():
        if last_length is None or (row['Length_m'] - last_length) == 20:
            current_segment.append((row['Length_m'], row['Elevation_m']))
        else:
            if current_segment:
                # If the gap is more than 20 meters, start a new segment
                segment_id = len(segments) + 1
                segments[segment_id] = current_segment
                current_segment = [(row['Length_m'], row['Elevation_m'])]
        last_length = row['Length_m']

    # Add the last segment if not empty
    if current_segment:
        segment_id = len(segments) + 1
        segments[segment_id] = current_segment

    return segments

# Apply the segmentation to each cross-section
segmented_data = data_sorted.groupby('Cross_Section').apply(create_segments)

data=segmented_data["Segment 2"][1]
data_np = np.array(data)

# Extract the x and y components
x = data_np[:, 0]
y = data_np[:, 1]

import matplotlib.pyplot as plt

# Function to plot segments for a given cross-section and return segment endpoints
def plot_segments(cross_section, segments):
    plt.figure(figsize=(10, 6))
    plt.title(f'Cross-section: {cross_section}')
    plt.xlabel('Length (m)')
    plt.ylabel('Elevation (m)')

    segment_endpoints = {}

    # Plot each segment and record endpoints
    for segment_id, segment_points in segments.items():
        segment_lengths, segment_elevations = zip(*segment_points)
        plt.plot(segment_lengths, segment_elevations, label=f'Segment {segment_id}')

        # Store the first and last point of each segment
        segment_endpoints[segment_id] = {
            "first_point": (segment_lengths[0], segment_elevations[0]),
            "last_point": (segment_lengths[-1], segment_elevations[-1])
        }

    plt.legend()
    plt.grid(True)
    plt.show()

    return segment_endpoints

# Iterate over each cross-section, plot its segments, and collect endpoints
all_endpoints = {}
for cross_section, segments in segmented_data.items():
    endpoints = plot_segments(cross_section, segments)
    all_endpoints[cross_section] = endpoints

# Optionally, print the endpoints for each segment
for cross_section, endpoints in all_endpoints.items():
    print(f"Cross-section: {cross_section}")
    for segment_id, points in endpoints.items():
        print(f" Segment {segment_id}: First point {points['first_point']}, Last point {points['last_point']}")

import matplotlib.pyplot as plt

# Function to plot all segments sorted by the x-coordinate of the first point and print their endpoints
def plot_all_segments(segmented_data):
    plt.figure(figsize=(10, 6))
    plt.title('All Segments Sorted by Starting X Coordinate')
    plt.xlabel('Length (m)')
    plt.ylabel('Elevation (m)')

    # Collect all segments into a single list with their original section labels
    all_segments = []
    for cross_section, segments in segmented_data.items():
        for segment_id, segment_points in segments.items():
            all_segments.append((cross_section, segment_id, segment_points))

    # Sort all segments by the x-coordinate of the first point of each segment
    all_segments_sorted = sorted(all_segments, key=lambda item: item[2][0][0])

    # Plot each sorted segment and collect endpoints
    segment_endpoints = []
    for cross_section, segment_id, segment_points in all_segments_sorted:
        segment_lengths, segment_elevations = zip(*segment_points)
        plt.plot(segment_lengths, segment_elevations, label=f'{cross_section} - Segment {segment_id}')

        # Collect start and end points for each segment
        segment_endpoints.append({
            "segment": f'{cross_section} - Segment {segment_id}',
            "start_point": (segment_lengths[0], segment_elevations[0]),
            "end_point": (segment_lengths[-1], segment_elevations[-1])
        })

    plt.legend(loc='upper right', bbox_to_anchor=(1.15, 1))
    plt.grid(True)
    plt.show()

    # Print start and end points for each segment
    print("Sorted Segment Endpoints:")
    for endpoint in segment_endpoints:
        print(f"{endpoint['segment']}: Start {endpoint['start_point']}, End {endpoint['end_point']}")

# Example usage assuming `segmented_data` is your dictionary containing all sections and their segments
plot_all_segments(segmented_data)

x0, y0 = simulation(sim, -10000, 3200, 420, 749.064216, [-2, 0.7], 5, pts=200)
print(x0.shape,y0.shape)

n_sims = 1

#Segment 2 - Segment 1: Start (5100, 718.5171644), End (5660, 719.55386) 478.27;S
s1=np.array(segmented_data["Segment 1"][1])#856.66 al Norte
#s5=np.array(segmented_data["Segment 5"][1])#856.66 al Norte
#s4=np.array(segmented_data["Segment 4"][1])

xs4, ys4 = interpolate(sim,3200,3560, s1, 749.064216, 856.66 ,200, [-1, 1], n_sims)
x0, y0 = simulation(sim, -49314.9, 3000, 420, find_y_at_x(xs4, ys4,3200), [-1.5, 1.7], n_sims)
#x0, y0 = simulation(sim, -49314.9, 3000, 380, 750, [-1.5, 2], n_sims)
x1, y1 = simulation(sim, 3640, 3680, find_y_at_x(xs4,ys4,3560), 740.5486169, [1, -1], n_sims)
xc1, yc1 = to_xy(segmented_data["Cross-section N1"][1], n_sims)
xc12, yc12 = to_xy(segmented_data["Cross-section N1"][2], n_sims)

generator = ProfileGenerator()
generator.add_reference_points(s1[:, 0], s1[:, 1], "Original Segment 1")
#generator.add_reference_points(s4[:, 0], s4[:, 1], "Original Segment 4")
#generator.add_reference_points(s5[:, 0], s5[:, 1], "Original Segment 5")
generator.add_profile_segment(x0, y0)
generator.add_profile_segment(xs4, ys4)
generator.add_profile_segment(x1, y1)
generator.add_reference_points(xc1, yc1[0], "Cross-section N1-s1")
generator.add_reference_points(xc12, yc12[0], "Cross-section N1-s2")
generator.add_profile_segment(xc1, yc1)
generator.add_profile_segment(xc12, yc12)
generator.plot_profiles(vertical_exaggeration=1,figsize=(10, 5))

generator = ProfileGenerator()
generator.add_profile_segment(x0, y0)

generator.add_profile_segment(x1, y1)

generator.add_reference_points(xc1, yc1[0], "Cross-section N1-s1")
generator.add_reference_points(xc12, yc12[0], "Cross-section N1-s2")
generator.add_profile_segment(xc1, yc1)
generator.add_profile_segment(xc12, yc12)
generator.add_reference_points(s1[:, 0], s1[:, 1], "Original Segment 1")
generator.plot_profiles(vertical_exaggeration=1,figsize=(10, 5))



"""# Others"""

def concatenate_filtered_segments(segmented_data, segments_to_join, thresholds):
    # Convert tuples to numpy array and filter based on thresholds
    joined_array = np.concatenate([
        np.array(segmented_data[segment][1])[
            np.logical_and(
                np.array(segmented_data[segment][1])[:, 0] >= thresholds.get(segment, (float('-inf'), float('inf')))[0],
                np.array(segmented_data[segment][1])[:, 0] <= thresholds.get(segment, (float('-inf'), float('inf')))[1]
            )
        ]
        for segment in segments_to_join if segment in segmented_data and 1 in segmented_data[segment]
    ])

    return joined_array

#Cross-section N1 - Segment 2: Start (4640, 732.1687385), End (5060, 720.3722982)
#Segment 2 - Segment 1: Start (5100, 718.5171644), End (5660, 719.55386)
#Cross-section N1 - Segment 3: Start (13340, 619.2092539), End (13580, 618.5145313)

s2=np.array(segmented_data["Segment 2"][1])
#s3=np.array(segmented_data["Segment 3"][1]) #497.96 N
s6=np.array(segmented_data["Segment 6"][1]) #2019.15 S
s7=np.array(segmented_data["Segment 7"][1]) #5512.55 N
s49=np.array(segmented_data["Segment 49"][1]) #5512.55 N
s50=np.array(segmented_data["Segment 50"][1]) #5512.55 N
s52=np.array(segmented_data["Segment 52"][1]) #5512.55 N
#s8=np.array(segmented_data["Segment 8"][1]) #5275.05 N

segments_to_join1 = ["Segment 7", "Segment 49","Segment 50"]
segments_to_join2 = ["Segment 52"]
thresholds1 = {
    "Segment 7": (7340, 8180),
    "Segment 49": (8200, 9240),
    "Segment 50": (9540, 12300)
}
thresholds2 = {
    "Segment 52": (12560, 13020)
}
free_joined_array1 =concatenate_filtered_segments(segmented_data,segments_to_join1,thresholds1)
free_joined_array2 =concatenate_filtered_segments(segmented_data,segments_to_join2,thresholds2)
s78=np.array(free_joined_array1)
s5052=np.array(free_joined_array2)
#d=22820

xs2, ys2 = interpolate(sim,5100,5660, s2, 722, 478.27 ,1000, [1, -1], n_sims)
xs6, ys6 = interpolate(sim,5900,7260, s6, 720, 2019.15 ,1000, [1, -1], n_sims)
xs7, ys7 = interpolate(sim,7340,12300, s78, np.linspace(690,680,len(s78)), 5512.55 ,1000, [1, -1], n_sims)
xs50, ys50 = interpolate(sim,12300,13320, s5052, 620, 1600 ,400, [1, -1], n_sims)

x2, y2 = simulation(sim, 5660, 5900, find_y_at_x(xs2, ys2,5660), find_y_at_x(xs6, ys6,5900), [1.5, -1.5], n_sims)
xc13, yc13 = to_xy(segmented_data["Cross-section N1"][3], n_sims)

generator = ProfileGenerator()
generator.add_reference_points(s2[:, 0], s2[:, 1], "Original Segment 2")
generator.add_reference_points(s49[:, 0], s49[:, 1], "Original Segment 49")
#generator.add_reference_points(s50[:, 0], s50[:, 1], "Original Segment 50")
generator.add_reference_points(s52[:, 0], s52[:, 1], "Original Segment 52")
generator.add_reference_points(s6[:, 0], s6[:, 1], "Original Segment 6")
generator.add_reference_points(s7[:, 0], s7[:, 1], "Original Segment 7")
generator.add_reference_points(s78[:, 0], s78[:, 1], "Original Segmentsss")
generator.add_profile_segment(xc12, yc12)
generator.add_profile_segment(xs2, ys2)
generator.add_profile_segment(x2, y2)
generator.add_profile_segment(xs6, ys6)
generator.add_profile_segment(xs7, ys7)
generator.add_profile_segment(xs50, ys50)
generator.add_reference_points(xc13, yc13[0], "Cross-section N1-s3")
generator.add_profile_segment(xc13, yc13)
generator.plot_profiles(vertical_exaggeration=1,figsize=(10, 5))

#Cross-section N1 - Segment 3: Start (13340, 619.2092539), End (13580, 618.5145313)
#Segment 10 - Segment 1: Start (14660, 601.4472171), End (15360, 601.2817758)
#Cross-section N1 - Segment 4: Start (19100, 575.8084155), End (19140, 574.7898845)

s51=np.array(segmented_data["Segment 51"][1])

s12=np.array(segmented_data["Segment 12"][1]) #2607.25 S
s16=np.array(segmented_data["Segment 16"][1]) #2637.31 S

s15=np.array(segmented_data["Segment 15"][1]) #2528.99 S
s11=np.array(segmented_data["Segment 11"][1]) #2450.5 S

s18=np.array(segmented_data["Segment 18"][1]) #2365.67 S #18560
s17=np.array(segmented_data["Segment 17"][1]) #2151.28 S
s19=np.array(segmented_data["Segment 19"][1]) #2151.28 S

segments_to_join = ["Segment 12", "Segment 16","Segment 11"]

thresholds3 = {
    "Segment 12": (15690, 25700)
    }
free_joined_array =concatenate_filtered_segments(segmented_data,segments_to_join,thresholds3)
s1216=np.array(free_joined_array)

xs51, ys51 = interpolate(sim,13760,13960, s51, 618.5145313, 2892.39 ,100, [1, 0], n_sims)
xs1216, ys1216 = interpolate(sim,15600,16520, s1216, 600, 2637.31 ,2000, [1, 0], n_sims)
x3, y3 = simulation(sim, 13960, 15600, find_y_at_x(xs51, ys51,13960), find_y_at_x(xs1216, ys1216,15600), [-2, 1], n_sims)
#"Segment 15",
#segments_to_join = ["Segment 11"]
#free_joined_array =concatenate_filtered_segments(segmented_data,segments_to_join,{})
#s1511=np.array(free_joined_array) #15560 to 16520

#xs1511, ys1511 = interpolate(sim, 15820, 16520, s1511, 600, 2450.5 ,2000, [1, 0], n_sims)

segments_to_join = ["Segment 17", "Segment 18", "Segment 19"]

thresholds5 = {
    "Segment 17": (18460, 18520)
    }
free_joined_array =concatenate_filtered_segments(segmented_data,segments_to_join,thresholds5)
s178=np.array(free_joined_array) #18560 to 18700

xs17, ys17 = interpolate(sim, 18460, 19080, s178, 590, 2151.28 ,100, [1, 0], n_sims)

x4, y4 = simulation(sim, 16520, 18460, find_y_at_x(xs1216, ys1216,16520), find_y_at_x(xs17, ys17,18460), [1, -2], n_sims)

x41, y41 = simulation(sim, 19080, 19100, find_y_at_x(xs17, ys17,19080), 575.8084155, [1, -2], n_sims)

xc14, yc14 = to_xy(segmented_data["Cross-section N1"][4], n_sims)

generator = ProfileGenerator()
generator.add_reference_points(xc13, yc13[0], "Cross-section N1-s3")
generator.add_profile_segment(xc13, yc13)
generator.add_reference_points(s51[:, 0], s51[:, 1], "Original Segment 51")
generator.add_reference_points(s12[:, 0], s12[:, 1], "Original Segment 12")
generator.add_reference_points(s16[:, 0], s16[:, 1], "Original Segment 16")
generator.add_reference_points(s15[:, 0], s15[:, 1], "Original Segment 15")
generator.add_reference_points(s11[:, 0], s11[:, 1], "Original Segment 11")
generator.add_reference_points(s178[:, 0], s178[:, 1], "Original Segment 17,18,19")
generator.add_profile_segment(xs51, ys51)
generator.add_profile_segment(x3, y3)
generator.add_profile_segment(xs1216, ys1216)
#generator.add_profile_segment(xs1511, ys1511)
generator.add_profile_segment(x4, y4)
generator.add_profile_segment(xs17, ys17)
generator.add_profile_segment(x41, y41)
generator.add_reference_points(xc14, yc14[0], "Cross-section N1-s4")
generator.add_profile_segment(xc14, yc14)
generator.plot_profiles(vertical_exaggeration=1,figsize=(20, 5))

generator.plot_profiles(vertical_exaggeration=1,figsize=(10, 5))

xf = np.array([26915.9999999991,26903.9999999992,26891.9999999992,26879.9999999992,26867.9999999993,26855.9999999993,26843.9999999994,26831.9999999994,26819.9999999994,26807.999999999,26795.999999999,26783.999999999,26771.9999999991,26759.9999999991,26747.9999999992,26735.9999999992,26723.9999999993,26711.9999999993,26699.9999999993,26687.9999999993,26675.9999999994,26663.9999999994,26651.999999999,26639.999999999,26627.9999999991,26615.9999999991,26603.9999999991,26591.9999999992,26579.9999999992,26567.9999999992,26555.9999999992,26543.9999999993,26531.9999999993,26519.9999999994,26507.9999999994,26495.999999999,26483.999999999,26471.9999999991,26459.9999999991,26447.9999999991,26435.9999999991,26423.9999999992,26411.9999999992,26399.9999999993,26387.9999999993,26375.9999999993,26363.9999999994,26351.9999999994,26339.9999999994,26327.999999999,26315.999999999,26303.9999999991,26291.9999999991,26279.9999999991,26267.9999999992,26255.9999999992,26243.9999999993,26231.9999999993,26219.9999999993,26207.9999999993,26195.9999999994,26183.9999999994,26171.999999999,26159.999999999,26147.9999999991,26135.9999999991,26123.9999999992,26111.9999999992,26099.9999999992,26087.9999999992,26075.9999999993,26063.9999999993,26051.9999999993,26039.9999999994,26027.9999999994,26015.9999999995,26003.999999999,25991.9999999991,25979.9999999991,25967.9999999991,25955.9999999992,25943.9999999992,25931.9999999992,25919.9999999993,25907.9999999993,25895.9999999994,25883.9999999994,25871.9999999994,25859.9999999994,25847.999999999,25835.999999999,25823.9999999991,25811.9999999991,25799.9999999991,25787.9999999992,25775.9999999992,25763.9999999993,25751.9999999993,25739.9999999993,25727.9999999994,25715.9999999994,25703.9999999994,25691.9999999995,25679.999999999,25667.9999999991,25655.9999999991,25643.9999999992,25631.9999999992,25619.9999999992,25607.9999999992,25595.9999999993,25583.9999999993,25571.9999999993,25559.9999999994,25547.9999999994,25535.9999999995,25523.999999999,25511.9999999991,25499.9999999991,25487.9999999991,25475.9999999992,25463.9999999992,25451.9999999992,25439.9999999993,25427.9999999993,25415.9999999994,25403.9999999994,25391.9999999994,25379.9999999994,25367.999999999,25355.9999999991,25343.9999999991,25331.9999999991,25319.9999999991,25307.9999999992,25295.9999999992,25283.9999999993,25271.9999999993,25259.9999999993,25247.9999999994,25235.9999999994,25223.9999999994,25211.9999999995,25199.999999999,25187.9999999991,25175.9999999991,25163.9999999992,25151.9999999992,25139.9999999992,25127.9999999993,25115.9999999993,25103.9999999993,25091.9999999993,25079.9999999994,25067.9999999994,25055.9999999995,25043.999999999,25031.9999999991,25019.9999999991,25007.9999999992,24995.9999999992,24983.9999999992,24971.9999999992,24959.9999999993,24947.9999999993,24935.9999999994,24923.9999999994,24911.9999999994,24899.9999999995,24887.9999999995,24875.9999999991,24863.9999999991,24851.9999999991,24839.9999999992,24827.9999999992,24815.9999999992,24803.9999999993,24791.9999999993,24779.9999999994,24767.9999999994,24755.9999999994,24743.9999999994,24731.9999999995,24719.999999999,24707.9999999991,24695.9999999991,24683.9999999992,24671.9999999992,24659.9999999993,24647.9999999993,24635.9999999993,24623.9999999993,24611.9999999994,24599.9999999994,24587.9999999994,24575.9999999995,24563.9999999995,24551.9999999991,24539.9999999991,24527.9999999992,24515.9999999992,24503.9999999992,24491.9999999992,24479.9999999993,24467.9999999993,24455.9999999994,24443.9999999994,24431.9999999995,24419.9999999995,24407.9999999995,24395.9999999991,24383.9999999991,24371.9999999991,24359.9999999992,24347.9999999992,24335.9999999993,24323.9999999993,24311.9999999993,24299.9999999994,24287.9999999994,24275.9999999994,24263.9999999994,24251.9999999995,24239.9999999991,24227.9999999991,24215.9999999991,24203.9999999992,24191.9999999992,24179.9999999993,24167.9999999993,24155.9999999993,24143.9999999993,24131.9999999994,24119.9999999994,24107.9999999995,24095.9999999995,24083.9999999996,24071.9999999991,24059.9999999992,24047.9999999992,24035.9999999992,24023.9999999992,24011.9999999993,23999.9999999993,23987.9999999993,23975.9999999994,23963.9999999994,23951.9999999995,23939.9999999995,23927.9999999995,23915.9999999991,23903.9999999991,23891.9999999992,23879.9999999992,23867.9999999992,23855.9999999993,23843.9999999993,23831.9999999994,23819.9999999994,23807.9999999994,23795.9999999994,23783.9999999995,23771.9999999995,23759.9999999995,23747.9999999991,23735.9999999991,23723.9999999992,23711.9999999992,23699.9999999993,23687.9999999993,23675.9999999993,23663.9999999994,23651.9999999994,23639.9999999994,23627.9999999995,23615.9999999995,23603.9999999996,23591.9999999991,23579.9999999992,23567.9999999992,23555.9999999992,23543.9999999992,23531.9999999993,23519.9999999993,23507.9999999993,23495.9999999994,23483.9999999994,23471.9999999995,23459.9999999995,23447.9999999995,23435.9999999991,23423.9999999991,23411.9999999992,23399.9999999992,23387.9999999992,23375.9999999993,23363.9999999993,23351.9999999994,23339.9999999994,23327.9999999994,23315.9999999994,23303.9999999995,23291.9999999995,23279.9999999996,23267.9999999991,23255.9999999991,23243.9999999992,23231.9999999992,23219.9999999993,23207.9999999993,23195.9999999993,23183.9999999994,23171.9999999994,23159.9999999994,23147.9999999995,23135.9999999995,23123.9999999996,23111.9999999991,23099.9999999992,23087.9999999992,23075.9999999992,23063.9999999993,23051.9999999993,23039.9999999993,23027.9999999993,23015.9999999994,23003.9999999994,22991.9999999995,22979.9999999995,22967.9999999995,22955.9999999996,22943.9999999992,22931.9999999992,22919.9999999992,22907.9999999992,22895.9999999993,22883.9999999993,22871.9999999994,22859.9999999994,22847.9999999994,22835.9999999995,22823.9999999995,22811.9999999995,22799.9999999995,22787.9999999991,22775.9999999992,22763.9999999992,22751.9999999992,22739.9999999993,22727.9999999993,22715.9999999994,22703.9999999994,22691.9999999994,22679.9999999994,22667.9999999995,22655.9999999995,22643.9999999996,22631.9999999996,22619.9999999992,22607.9999999992,22595.9999999993,22583.9999999993,22571.9999999993,22559.9999999993,22547.9999999994,22535.9999999994,22523.9999999994,22511.9999999995,22499.9999999995,22487.9999999996,22475.9999999996,22463.9999999992,22451.9999999992,22439.9999999992,22427.9999999992,22415.9999999993,22403.9999999993,22391.9999999994,22379.9999999994,22367.9999999995,22355.9999999995,22343.9999999995,22331.9999999995,22319.9999999996,22307.9999999991,22295.9999999992,22283.9999999992,22271.9999999993,22259.9999999993,22247.9999999993,22235.9999999994,22223.9999999994,22211.9999999994,22199.9999999994,22187.9999999995,22175.9999999995,22163.9999999996,22151.9999999996,22139.9999999992,22127.9999999992,22115.9999999993,22103.9999999993,22091.9999999993,22079.9999999993,22067.9999999994,22055.9999999994,22043.9999999995,22031.9999999995,22019.9999999995,22007.9999999996,21995.9999999996,21983.9999999992,21971.9999999992,21959.9999999992,21947.9999999993,21935.9999999993,21923.9999999993,21911.9999999994,21899.9999999994,21887.9999999995,21875.9999999995,21863.9999999995,21851.9999999995,21839.9999999996,21827.9999999996,21815.9999999992,21803.9999999992,21791.9999999993,21779.9999999993,21767.9999999994,21755.9999999994,21743.9999999994,21731.9999999994,21719.9999999995,21707.9999999995,21695.9999999995,21683.9999999996,21671.9999999996,21659.9999999992,21647.9999999992,21635.9999999993,21623.9999999993,21611.9999999993,21599.9999999994,21587.9999999994,21575.9999999994,21563.9999999995,21551.9999999995,21539.9999999996,21527.9999999996,21515.9999999996,21503.9999999996,21491.9999999992,21479.9999999992,21467.9999999993,21455.9999999993,21443.9999999993,21431.9999999994,21419.9999999994,21407.9999999995,21395.9999999995,21383.9999999995,21371.9999999996,21359.9999999996,21347.9999999996,21335.9999999992,21323.9999999992,21311.9999999993,21299.9999999993,21287.9999999994,21275.9999999994,21263.9999999994,21251.9999999994,21239.9999999995,21227.9999999995,21215.9999999995,21203.9999999996,21191.9999999996,21179.9999999992,21167.9999999992,21155.9999999993,21143.9999999993,21131.9999999993,21119.9999999994,21107.9999999994,21095.9999999994,21083.9999999995,21071.9999999995,21059.9999999996,21047.9999999996,21035.9999999996,21023.9999999996,21011.9999999992,20999.9999999993,20987.9999999993,20975.9999999993,20963.9999999993,20951.9999999994,20939.9999999994,20927.9999999995,20915.9999999995,20903.9999999995,20891.9999999996,20879.9999999996,20867.9999999996,20855.9999999992,20843.9999999992,20831.9999999993,20819.9999999993,20807.9999999994,20795.9999999994,20783.9999999994,20771.9999999995,20759.9999999995,20747.9999999995,20735.9999999995,20723.9999999996,20711.9999999996,20699.9999999997,20687.9999999992,20675.9999999993,20663.9999999993,20651.9999999994,20639.9999999994,20627.9999999994,20615.9999999994,20603.9999999995,20591.9999999995,20579.9999999996,20567.9999999996,20555.9999999996,20543.9999999997,20531.9999999993,20519.9999999993,20507.9999999993,20495.9999999993,20483.9999999994,20471.9999999994,20459.9999999994,20447.9999999995,20435.9999999995,20423.9999999996,20411.9999999996,20399.9999999996,20387.9999999996,20375.9999999992,20363.9999999992,20351.9999999993,20339.9999999993,20327.9999999994,20315.9999999994,20303.9999999995,20291.9999999995,20279.9999999995,20267.9999999995,20255.9999999996,20243.9999999996,20231.9999999996,20219.9999999997,20207.9999999993,20195.9999999993,20183.9999999993,20171.9999999994,20159.9999999994,20147.9999999994,20135.9999999994,20123.9999999995,20111.9999999995,20099.9999999996,20087.9999999996,20075.9999999997,20063.9999999997,20051.9999999993,20039.9999999993,20027.9999999993,20015.9999999993,20003.9999999994,19991.9999999994,19979.9999999995,19967.9999999995,19955.9999999995,19943.9999999996,19931.9999999996,19919.9999999996,19907.9999999996,19895.9999999997,19883.9999999993,19871.9999999993,19859.9999999993,19847.9999999994,19835.9999999994,19823.9999999995,19811.9999999995,19799.9999999995,19787.9999999995,19775.9999999996,19763.9999999996,19751.9999999997,19739.9999999997,19727.9999999992,19715.9999999993,19703.9999999994,19691.9999999994,19679.9999999994,19667.9999999994,19655.9999999995,19643.9999999995,19631.9999999995,19619.9999999996,19607.9999999996,19595.9999999997,19583.9999999997,19571.9999999997,19559.9999999993,19547.9999999993,19535.9999999994,19523.9999999994,19511.9999999994,19499.9999999995,19487.9999999995,19475.9999999996,19463.9999999996,19451.9999999996,19439.9999999996,19427.9999999997,19415.9999999997,19403.9999999993,19391.9999999993,19379.9999999993,19367.9999999994,19355.9999999994,19343.9999999995,19331.9999999995,19319.9999999995,19307.9999999996,19295.9999999996,19283.9999999996,19271.9999999997,19259.9999999997,19247.9999999993,19235.9999999993,19223.9999999994,19211.9999999994,19199.9999999994,19187.9999999994,19175.9999999995,19163.9999999995,19151.9999999995,19139.9999999996,19127.9999999996,19115.9999999997,19103.9999999997,19091.9999999997,19079.9999999993,19067.9999999993,19055.9999999994])
yf = np.array([377.102907739668,380.473184245308,383.764716508941,385.351513606711,385.361037557368,384.947566627673,383.715395204441,382.628270067314,383.420054250198,385.668708889879,388.259732436425,389.852750407797,391.292060431465,392.531890958565,394.693346220658,397.14297911807,401.122139674226,406.267111447584,411.784317505135,416.325185110926,418.48486777919,419.03366294171,419.115019785296,419.147339883536,419.221700369746,418.761245100798,418.020292766448,416.993741263041,415.291204821956,412.635139685559,410.047760777825,407.838381504675,404.373540396125,401.483433582803,399.518316714563,398.601962753439,397.490336823482,395.296512359931,391.448819615842,387.230414692376,381.874677360676,377.138340553855,372.737223920136,369.620477256522,366.76385503797,365.605919130779,367.029265682189,369.032137424289,370.087288743867,372.132195739595,373.001444812916,372.81419300634,371.261290354603,369.613118883757,368.490515414501,367.436919715609,366.006392144183,364.021220957345,361.134309960356,357.710315512491,352.503943357583,345.56711380785,340.396246216609,335.896233196748,333.995512721878,332.879582789568,331.590779675916,331.283013841948,331.634582807014,331.234939391898,330.313220900077,329.645550854641,330.959265356589,332.305360669979,333.086548816651,335.257232986444,337.27396722647,338.929199169652,338.760881743782,339.054684187202,337.903660018618,337.794526778951,336.795551352796,334.887694618728,331.643738565802,327.020646876625,321.780269547908,315.812736090509,309.666201855626,303.579881804275,298.538709592195,294.386236016663,291.374585454644,289.727392096412,289.947071071887,290.683987764922,292.047933406955,294.73335572701,297.723059762938,300.101835581428,300.7453814098,298.249890240024,293.883221712778,289.093884510777,284.420394675237,280.5796378723,277.477144348577,275.011232023172,272.817850570322,270.923082990501,269.641213313837,269.074589347275,268.662586119439,268.306093895076,268.18847161695,267.943259688685,267.771595312986,267.593163296627,267.600748960919,267.16027597223,266.713588946386,266.238161077048,265.84341136191,265.108433526974,264.959902561191,265.094110083498,264.15624913711,263.539672665086,263.031097040469,262.293073052919,261.683123771502,261.230339829283,260.181102762201,257.961926108047,256.945837812908,255.734780591943,255.058965374389,254.654662687406,254.312902820179,254.130917473528,254.342614880597,254.731671536487,254.705500981386,254.808043114642,255.03091498871,255.224816998252,254.751447089607,254.573075839846,254.455183435787,254.293122594875,254.357813025927,254.548978817241,254.594373405969,254.632701299036,254.924769147256,254.426522627593,253.905988696422,253.573907179984,253.935650612357,253.556698869264,253.255554318861,253.12200168388,253.179217387817,253.483950715824,253.30202391803,253.272892249314,253.920275559662,254.153299011831,253.704073317493,253.169146714743,252.87140362185,253.295013220539,252.790701562427,252.446473227065,252.178574002272,251.858936063483,251.574060915256,252.078482983007,251.906524068192,252.187409292635,252.412529225749,251.600843656365,251.035332197713,250.846998931873,250.669553690299,250.606995403029,251.093484993028,251.463684878585,251.21481282044,251.92489633661,254.586275484972,259.238067775617,264.737465651711,270.209637867093,274.773175659382,277.083100204279,279.584393848255,281.895523364043,285.226928445476,290.240852918983,295.565850548871,301.842672422413,309.198461769247,315.966225308081,318.818510373312,318.525832433542,317.959315457719,318.548496216185,319.296423433847,321.197609504738,322.996867701702,325.003848442886,327.235920999391,330.231748870307,333.96570530056,337.845236031486,342.458165996824,346.91333015941,351.529347677059,357.114521496427,362.425930696635,368.21655498067,374.449326602242,380.297824650364,386.43382616051,392.742990840044,398.032131671555,402.354934427689,406.724970497431,410.467492326525,413.967091519008,416.781950089286,418.840524133692,420.014222592618,420.405750688788,420.662025625717,420.828836795854,421.213105158106,421.647435135069,422.565658457383,423.178714799189,423.481567547838,423.694412090839,423.450352663425,423.390125860578,423.263699534964,423.0598162806,423.058579379393,423.130822584825,423.47547718631,424.496648644571,425.735831539078,427.181132460466,428.082972100216,427.88130764838,428.508468556355,429.005498669722,429.634295683942,429.947935449124,429.78170782518,429.481727195819,430.05162025404,431.385929371665,431.631981122581,431.994582983082,432.552732119062,433.089543289611,433.546839425556,434.307735043911,434.635925378362,435.046195372913,435.52676218925,435.937975465862,435.816389735488,435.760241192063,436.20886081358,436.850899274801,437.362942873899,437.678189338597,438.204453801142,438.639409304807,438.961472808674,438.955877532864,439.45706107842,440.067223805776,440.216985681808,440.677905546649,440.277592142981,440.179554136931,440.313645765891,440.5422130434,440.901055844681,441.135852443646,441.44290238421,442.038645541051,442.279514739643,442.479839722128,443.040824760485,443.569033841326,444.184639761276,444.900759900547,445.72860722361,445.875695585148,446.310259236715,446.552801421527,446.915487159186,447.195625400631,447.395512624578,447.966126805514,448.108200731873,448.386467300413,448.52812806811,448.988261001466,449.581044820687,450.045851622839,450.549482877728,450.980308254787,450.913349540561,450.988157142013,451.133021934778,451.466455523275,451.923684633758,452.17660817776,452.335110207869,452.079648450733,452.624435434159,453.320699125319,453.32883603886,453.496059690453,453.725248726609,454.202050044844,454.654580803552,454.885795467257,455.11112744653,455.322736785693,455.9642606555,456.297445745508,456.451795887773,456.915569974599,457.23979133778,457.251845098901,457.735049318629,458.105518120401,458.667245965104,459.011613996262,458.889157679473,459.024767674019,459.191427946159,459.540373748309,459.237118490971,459.231761624118,459.721366429273,459.735062022272,460.019611641961,460.558200836555,461.558726630674,460.839329942354,461.57787118138,461.966779755934,462.179278428964,462.693619082724,463.463204386545,463.470306126309,463.710805670506,464.036216646684,464.390492160114,464.665573251666,465.181846352685,465.507916491791,465.731105741772,465.996038888592,466.159901602566,466.61058216526,466.733188777321,467.007765574025,467.538353814661,467.811870606419,468.087382135814,468.792491482304,469.428541494818,469.689945448696,469.672779999668,469.581287791523,469.888554869231,470.242482401544,470.095029545471,470.387442167148,470.72301195003,471.342446777744,471.807465333311,472.01577483744,472.250938620373,472.741008647907,473.010745890148,473.460557832946,473.520220321647,473.753786948152,474.171127798766,474.549440921071,474.949771602222,475.425989913532,475.986740562542,476.324864058768,476.607025347107,476.783578152317,477.231697844625,477.692486654626,477.715028530477,478.14060444781,478.527312998173,478.968396004381,479.329143991734,479.614190404829,480.297117007637,480.618179950592,481.024324969945,481.398227662518,481.757919663949,482.207674254144,482.614535120056,482.797624633648,482.787510116552,483.034895840713,483.205064685993,483.777415461382,484.253392142815,484.676660529398,485.566073520113,486.498627177498,486.820709351105,486.970725770469,487.624366862419,487.774513780846,488.06921530951,488.20736055025,487.772601676062,487.419210355481,487.824545820672,488.372164243154,488.859495784441,488.701056387265,488.994142868521,489.397898303105,489.542934523177,490.033253873291,491.12963047046,492.101874999983,492.833393778244,493.518676834281,494.000571671622,493.715951395667,493.084709801379,492.727724501878,492.47536395368,492.441436382301,492.536055736622,492.247894445706,492.362098237581,493.55585608164,494.723227802824,495.667250453912,496.181651712469,497.253187400009,499.523580659337,500.285053396616,501.503877261291,501.896212461786,502.072297618824,502.777451994493,503.1730033911,503.328878182911,504.133341189657,504.977763461442,505.763493320906,506.140291780705,506.597887701314,506.911377394291,506.850846016969,507.447204511049,508.105935336317,508.603293604282,509.390028831649,510.037003987706,510.222221751834,510.170957676107,510.303694759069,511.105318141605,511.699199526046,512.202676779919,512.144720770453,512.312484103106,512.619727159447,513.296682266331,514.203682265612,514.600064406266,513.755682335747,512.95691793256,513.574710001121,514.634847070018,515.36775987247,515.120202189547,515.73495322455,516.915762149666,518.676860091829,519.946442185706,520.179015299554,520.002045708814,519.866493169451,518.094790731096,515.970535943761,514.044630622706,512.450275063512,511.17843159767,510.03377353534,509.136055552713,508.5098391691,507.382130030875,506.756149984406,505.652751604031,505.091008878351,504.616025962949,504.212928427334,503.84523117354,503.581276992983,503.749384310648,503.948351206405,503.550388738607,503.335448034458,503.327198320215,503.07994163047,503.040618729462,503.340566954906,503.284538210173,503.439038392695,504.422930584544,505.469350419053,506.267177665597,506.268807773294,505.949674180245,505.79584648717,505.785088795514,505.750556516136,505.792731466511,505.861068623163,505.512585261052,505.384618607065,506.756067297758,507.870207742293,509.00060162327,510.553532257089,512.745080322068,514.575918919454,515.472708969025,515.982573460394,516.474797453335,516.637750003342,515.921719031527,515.286026490118,515.602681833867,516.5928196633,517.820965340602,519.630853986901,521.398421544382,523.191832653832,524.643698748333,525.102867258576,524.447356448379,523.321938938279,521.931472507098,521.340345590684,520.360968398695,519.88778920585,519.660932764274,519.482538225476,519.6262594294,519.52497126583,519.567125431975,520.124965345792,520.608903308509,521.56672853183,522.515704309813,523.046482745777,523.317992709144,523.226254455939,523.317582346359,523.170385179933,522.784353890265,522.019351272411,521.31688962472,520.710143550763,520.144746644832,519.586027851107,519.136625745292,517.989014320703,517.409434375154,517.812163851509,518.473207609681,518.686384547176,518.771239408849,518.82585988476,518.912914102746,519.040350911325,519.486814440552,519.910952740565,520.352027311295,521.004241945052,521.397858652354,521.713760435418,522.002619432908,522.8703280828,523.549238837577,524.326143493655,524.47670810256,524.646128761325,525.390965818925,526.566851860993,527.73933585526,529.12545133877,530.553094382007,531.667918359024,532.711606885749,533.281764953539,533.965538659335,534.314093928683,533.971792600864,534.197563178983,534.801529874041,535.170267072887,535.842696865801,537.11678316023,538.077605382206,540.108125464704,542.880549458042,545.525693875716,547.603350577615,550.002692130499,552.60692237775,555.430528153529,558.309693858847,560.357401319573,562.529185652311,564.49255478918,566.308518796105,567.964061591796,569.436092390082,570.908209613331,572.607610028405,573.719366328481,574.789884427533,575.486894685261,575.987335115598,575.954127368399,575.329534384655,574.175941848768,572.753316206307,570.428179179337])

#Cross-section N1 - Segment 4: Start (19100, 575.8084155), End (19140, 574.7898845)
#Segment 23 - Segment 1: Start (19940, 569.5598923), End (20000, 569.3531371)
#Segment 21 - Segment 1: Start (20240, 562.7435549), End (20680, 550.8416391)
#Segment 26 - Segment 1: Start (21620, 535.1429871), End (21820, 525.3999007)
#Segment 27 - Segment 1: Start (21840, 524.3961813), End (21920, 521.3294861)
#Segment 29 - Segment 1: Start (22120, 514.6149891), End (22200, 509.5580652)
#Segment 30 - Segment 1: Start (22300, 500.7432442), End (22360, 496.5591873)
#Segment 36 - Segment 1: Start (22540, 487.6351338), End (22600, 484.5821156)
#Segment 37 - Segment 1: Start (22620, 483.0452468), End (22680, 482.0290551)
#Segment 40 - Segment 1: Start (23080, 459.2879659), End (23320, 449.7186991)
#Segment 41 - Segment 1: Start (23360, 446.8977319), End (23460, 443.5824197)
#Cross-section N1 - Segment 5: Start (26620, 418.9228746), End (26660, 419.1070984)
#Cross-section N1 - Segment 6: Start (30200, 433.1202355), End (30660, 439.0270368)
#Cross-section N1 - Segment 7: Start (31820, 447.4825594), End (39680, 496.797188)
#Cross-section N1 - Segment 8: Start (40100, 501.3339176), End (40620, 509.031276)

segments_to_join = ["Segment 20","Segment 32","Segment 23",  "Segment 22", "Segment 21",  "Segment 24",  "Segment 25",  "Segment 26", "Segment 27", "Segment 28",  "Segment 29",
                    "Segment 30", "Segment 35",  "Segment 36", "Segment 37", "Segment 38",  "Segment 47","Segment 48"]
thresholds = {
    "Segment 18": (18000, 18600),
    "Segment 17": (18500, 18540),
    "Segment 20": (19300, 19400)
}

segmentst = ["Topo"]
thresholdst = {"Topo": (19940, 26620)}

joined_array =concatenate_filtered_segments(segmented_data,segments_to_join,thresholds)
free_joined_array =concatenate_filtered_segments(segmented_data,segments_to_join,{})
s33=np.array(joined_array)
fs33=np.array(free_joined_array)
d=22820

xs33, ys33 = interpolate(sim,19940,d, s33, 550, 500 ,np.linspace(200,0,len(s33)), [1, -1], n_sims)
x5, y5 = simulation(sim, 19140, 19940, 574.789885, find_y_at_x(xs33, ys33,19940), [-1, 1], n_sims)
x6, y6 = simulation(sim, d, 26620, find_y_at_x(xs33, ys33,d), 418.9228746, [-2, 1.3], n_sims)
xc15, yc15 = to_xy(segmented_data["Cross-section N1"][5], n_sims)
xc16, yc16 = to_xy(segmented_data["Cross-section N1"][6], n_sims)
xc17, yc17 = to_xy(segmented_data["Cross-section N1"][7], n_sims)
xc18, yc18 = to_xy(segmented_data["Cross-section N1"][8], n_sims)
#s39=np.array(segmented_data["Segment 33"][1]) #2533.47 S

topo = concatenate_filtered_segments(segmented_data,segmentst,thresholdst)

generator = ProfileGenerator()
generator.add_reference_points(xc14, yc14[0], "Cross-section N1-s4")
generator.add_profile_segment(xc14, yc14)
#generator.add_reference_points(fs33[:, 0], fs33[:, 1], "Uncutted segments")
generator.add_reference_points(s33[:, 0], s33[:, 1], "North Segments")
#generator.add_reference_points(s39[:, 0], s39[:, 1], "S33")
generator.add_reference_points(xf, yf, "Topo")
generator.add_profile_segment(x5, y5)
generator.add_profile_segment(xs33, ys33)
generator.add_profile_segment(x6, y6)
generator.add_profile_segment(xc15, yc15)
generator.add_profile_segment(xc16, yc16)
generator.add_profile_segment(xc17, yc17)
generator.add_profile_segment(xc18, yc18)
generator.plot_profiles(vertical_exaggeration=1,figsize=(10, 5))

generator = ProfileGenerator()
generator.add_reference_points(s1[:, 0], s1[:, 1], "Original Segment 1")
#generator.add_reference_points(s4[:, 0], s4[:, 1], "Original Segment 4")
#generator.add_reference_points(s5[:, 0], s5[:, 1], "Original Segment 5")
generator.add_profile_segment(x0, y0)
generator.add_profile_segment(xs4, ys4)
generator.add_profile_segment(x1, y1)
generator.add_reference_points(xc1, yc1[0], "Cross-section N1-s1")
generator.add_reference_points(xc12, yc12[0], "Cross-section N1-s2")
generator.add_profile_segment(xc1, yc1)
generator.add_profile_segment(xc12, yc12)
generator.add_profile_segment(xs2, ys2)
generator.add_profile_segment(x2, y2)
generator.add_profile_segment(xs6, ys6)
generator.add_profile_segment(xs7, ys7)
generator.add_profile_segment(xs50, ys50)
generator.add_reference_points(xc13, yc13[0], "Cross-section N1-s3")
generator.add_profile_segment(xc13, yc13)
generator.add_profile_segment(xs51, ys51)
generator.add_profile_segment(x3, y3)
generator.add_profile_segment(xs1216, ys1216)
#generator.add_profile_segment(xs1511, ys1511)
generator.add_profile_segment(x4, y4)
generator.add_profile_segment(xs17, ys17)
generator.add_profile_segment(x41, y41)
generator.add_reference_points(xc14, yc14[0], "Cross-section N1-s4")
generator.add_profile_segment(xc14, yc14)
#generator.add_reference_points(fs33[:, 0], fs33[:, 1], "Uncutted segments")
generator.add_reference_points(s33[:, 0], s33[:, 1], "North Segments")
#generator.add_reference_points(s39[:, 0], s39[:, 1], "S33")
generator.add_reference_points(xf, yf, "Topo")
generator.add_profile_segment(x5, y5)
generator.add_profile_segment(xs33, ys33)
generator.add_profile_segment(x6, y6)
generator.add_profile_segment(xc15, yc15)
generator.add_profile_segment(xc16, yc16)
generator.add_profile_segment(xc17, yc17)
generator.add_profile_segment(xc18, yc18)
generator.plot_profiles(vertical_exaggeration=1,figsize=(10, 5))

"""# Result"""

generator.plot_profiles(vertical_exaggeration=1,figsize=(20, 5))

generator.interpolate_gaps(threshold=40)
generator.export_profiles('profiles_export.csv')
generator.export_reference_points('references_export.csv')

import random
def create_section(n_sims=1):
    s1=np.array(segmented_data["Segment 1"][1])#856.66 al Norte

    xs4, ys4 = interpolate(sim,3200,3560, s1, 749.064216, 856.66 ,200, [-1, 1], n_sims)
    x0, y0 = simulation(sim, random.uniform(-49314.9, -1000), 3000, 420, find_y_at_x(xs4, ys4,3200), [-1.5, 1.7], n_sims)
    x1, y1 = simulation(sim, 3640, 3680, find_y_at_x(xs4,ys4,3560), 740.5486169, [1, -1], n_sims)
    xc1, yc1 = to_xy(segmented_data["Cross-section N1"][1], n_sims)
    xc12, yc12 = to_xy(segmented_data["Cross-section N1"][2], n_sims)
    s2=np.array(segmented_data["Segment 2"][1])
    #s3=np.array(segmented_data["Segment 3"][1]) #497.96 N
    s6=np.array(segmented_data["Segment 6"][1]) #2019.15 S
    s7=np.array(segmented_data["Segment 7"][1]) #5512.55 N
    s49=np.array(segmented_data["Segment 49"][1]) #5512.55 N
    s50=np.array(segmented_data["Segment 50"][1]) #5512.55 N
    s52=np.array(segmented_data["Segment 52"][1]) #5512.55 N
    #s8=np.array(segmented_data["Segment 8"][1]) #5275.05 N

    segments_to_join1 = ["Segment 7", "Segment 49","Segment 50"]
    segments_to_join2 = ["Segment 52"]
    thresholds1 = {
        "Segment 7": (7340, 8180),
        "Segment 49": (8200, 9240),
        "Segment 50": (9540, 12300)
    }
    thresholds2 = {
        "Segment 52": (12560, 13020)
    }
    free_joined_array1 =concatenate_filtered_segments(segmented_data,segments_to_join1,thresholds1)
    free_joined_array2 =concatenate_filtered_segments(segmented_data,segments_to_join2,thresholds2)
    s78=np.array(free_joined_array1)
    s5052=np.array(free_joined_array2)
    #d=22820

    xs2, ys2 = interpolate(sim,5100,5660, s2, 722, 478.27 ,1000, [1, -1], n_sims)
    xs6, ys6 = interpolate(sim,5900,7260, s6, 720, 2019.15 ,1000, [1, -1], n_sims)
    xs7, ys7 = interpolate(sim,7340,12300, s78, np.linspace(690,680,len(s78)), 5512.55 ,1000, [1, -1], n_sims)
    xs50, ys50 = interpolate(sim,12300,13320, s5052, 620, 1600 ,400, [1, -1], n_sims)

    x2, y2 = simulation(sim, 5660, 5900, find_y_at_x(xs2, ys2,5660), find_y_at_x(xs6, ys6,5900), [1.5, -1.5], n_sims)
    xc13, yc13 = to_xy(segmented_data["Cross-section N1"][3], n_sims)


    s51=np.array(segmented_data["Segment 51"][1])

    s12=np.array(segmented_data["Segment 12"][1]) #2607.25 S
    s16=np.array(segmented_data["Segment 16"][1]) #2637.31 S

    s15=np.array(segmented_data["Segment 15"][1]) #2528.99 S
    s11=np.array(segmented_data["Segment 11"][1]) #2450.5 S

    s18=np.array(segmented_data["Segment 18"][1]) #2365.67 S #18560
    s17=np.array(segmented_data["Segment 17"][1]) #2151.28 S
    s19=np.array(segmented_data["Segment 19"][1]) #2151.28 S

    segments_to_join = ["Segment 12", "Segment 16","Segment 11"]

    thresholds3 = {
        "Segment 12": (15690, 25700)
        }
    free_joined_array =concatenate_filtered_segments(segmented_data,segments_to_join,thresholds3)
    s1216=np.array(free_joined_array)

    xs51, ys51 = interpolate(sim,13760,13960, s51, 618.5145313, 2892.39 ,100, [1, 0], n_sims)
    xs1216, ys1216 = interpolate(sim,15600,16520, s1216, 600, 2637.31 ,2000, [1, 0], n_sims)
    x3, y3 = simulation(sim, 13960, 15600, find_y_at_x(xs51, ys51,13960), find_y_at_x(xs1216, ys1216,15600), [-2, 1], n_sims)

    segments_to_join = ["Segment 17", "Segment 18", "Segment 19"]

    thresholds5 = {
        "Segment 17": (18460, 18520)
        }
    free_joined_array =concatenate_filtered_segments(segmented_data,segments_to_join,thresholds5)
    s178=np.array(free_joined_array) #18560 to 18700

    xs17, ys17 = interpolate(sim, 18460, 19080, s178, 590, 2151.28 ,100, [1, 0], n_sims)

    x4, y4 = simulation(sim, 16520, 18460, find_y_at_x(xs1216, ys1216,16520), find_y_at_x(xs17, ys17,18460), [1, -2], n_sims)

    x41, y41 = simulation(sim, 19080, 19100, find_y_at_x(xs17, ys17,19080), 575.8084155, [1, -2], n_sims)

    xc14, yc14 = to_xy(segmented_data["Cross-section N1"][4], n_sims)

    segments_to_join = ["Segment 20","Segment 32","Segment 23",  "Segment 22", "Segment 21",  "Segment 24",  "Segment 25",  "Segment 26", "Segment 27", "Segment 28",  "Segment 29",
                        "Segment 30", "Segment 35",  "Segment 36", "Segment 37", "Segment 38",  "Segment 47","Segment 48"]
    thresholds = {
        "Segment 18": (18000, 18600),
        "Segment 17": (18500, 18540),
        "Segment 20": (19300, 19400)
    }

    segmentst = ["Topo"]
    thresholdst = {"Topo": (19940, 26620)}

    joined_array =concatenate_filtered_segments(segmented_data,segments_to_join,thresholds)
    free_joined_array =concatenate_filtered_segments(segmented_data,segments_to_join,{})
    s33=np.array(joined_array)
    fs33=np.array(free_joined_array)
    d=22820

    xs33, ys33 = interpolate(sim,19940,d, s33, 550, 500 ,np.linspace(200,0,len(s33)), [1, -1], n_sims)
    x5, y5 = simulation(sim, 19140, 19940, 574.789885, find_y_at_x(xs33, ys33,19940), [-1, 1], n_sims)
    x6, y6 = simulation(sim, d, 26620, find_y_at_x(xs33, ys33,d), 418.9228746, [-2, 1.3], n_sims)
    xc15, yc15 = to_xy(segmented_data["Cross-section N1"][5], n_sims)
    xc16, yc16 = to_xy(segmented_data["Cross-section N1"][6], n_sims)
    xc17, yc17 = to_xy(segmented_data["Cross-section N1"][7], n_sims)
    xc18, yc18 = to_xy(segmented_data["Cross-section N1"][8], n_sims)

    generator = ProfileGenerator()
    generator.add_profile_segment(x0, y0)
    generator.add_profile_segment(xs4, ys4)
    generator.add_profile_segment(x1, y1)
    generator.add_profile_segment(xc1, yc1)
    generator.add_profile_segment(xc12, yc12)
    generator.add_profile_segment(xs2, ys2)
    generator.add_profile_segment(x2, y2)
    generator.add_profile_segment(xs6, ys6)
    generator.add_profile_segment(xs7, ys7)
    generator.add_profile_segment(xs50, ys50)
    generator.add_profile_segment(xc13, yc13)
    generator.add_profile_segment(xs51, ys51)
    generator.add_profile_segment(x3, y3)
    generator.add_profile_segment(xs1216, ys1216)
    generator.add_profile_segment(x4, y4)
    generator.add_profile_segment(xs17, ys17)
    generator.add_profile_segment(x41, y41)
    generator.add_profile_segment(xc14, yc14)
    generator.add_profile_segment(x5, y5)
    generator.add_profile_segment(xs33, ys33)
    generator.add_profile_segment(x6, y6)
    generator.add_profile_segment(xc15, yc15)
    generator.add_profile_segment(xc16, yc16)
    generator.add_profile_segment(xc17, yc17)
    generator.add_profile_segment(xc18, yc18)
    return generator

generator=create_section(n_sims=1)
generator.interpolate_gaps(threshold=40)
generator.export_profiles('profiles_export.csv')

generator.plot_profiles(vertical_exaggeration=1,figsize=(20, 5))

import pandas as pd


# Create a CSV for each simulation and then merge them into a single DataFrame
all_profiles = []
for i in range(100):
    generator = create_section(n_sims=1)
    generator.interpolate_gaps(threshold=40)
    filename = f'profiles_export_{i}.csv'
    generator.export_profiles(filename)
    df = pd.read_csv(filename)
    all_profiles.append(df)

# Concatenate all profiles into a single DataFrame
merged_profiles = pd.concat(all_profiles, axis=1)

# Save the merged profiles to a CSV
merged_profiles.to_csv('merged_profiles.csv', index=False)

